do you need me to say something?

Testing 1, 2, 1, 2. Hello, Function 1 2, 12.

Testing 1, 2, 1, 2. Hello World.

Alright, testing 123. Hopefully everyone can hear me okay.

Okay that was some amazing excitement I see in zoom.

Thank you so sorry to keep everyone.

Um,

we were just fixing some things I did wrong last week so that we have the

footage and just getting ready since it's a lot to take in all at once.

If you are new here, a few familiar,

a few perhaps unfamiliar announcements one everything for today is that CS 50

dot L y slash zoom at least in terms of the courses,

slides

will also post links to a,

what will be a souvenir photo later today if you're unfamiliar with using

zoom on a laptop or desktop and therefore might find yourself getting annoyed

by the chat window,

which is folks are interacting tends to you distract with a lot of pop ups,

we suggest that you do this clicked on the

little triangle to the left of the chat window,

you should seek some kind of pop out option at least in english and then

you can just kind of drag and drop it to the bottom of your screen.

This is technically a workaround,

but at least you won't see the annoying pop ups nearly as frequently

if you haven't already feel free to say hello to the world

and where you are in the world in the chat window.

Once we begin do try to keep the chatter focused on

the content specifically as opposed to just saying hello further,

just so folks can keep an eye out for questions and we can answer either

I'll do my best to answer or my colleague carter who's in back on chat,

whom you've seen as well.

Uh, if you would like to follow along with today's examples,

you can go to code dot CS 50 dot io and at

that you are l will be visual studio code in the cloud,

which you can sign into using a free Git hub account but there's

no expectation that you follow along live via that U R L.

Um, just realize that it's there for you as a resource.

But really the goal today is to do a number of introductions,

get you excited about some capabilities of python and

then in the problem set that's eventually released,

can you dive in

more hands on

before we take a few hellos and questions on camera? We do have this tradition.

If you'd like to turn on your camera,

if you would like to appear in this souvenir photo, turn off your camera.

If you would like to opt out,

I'm gonna go over here and stand in front of this as usual and

in just a moment if you want to put on your best smile or wave

our friend and wrong shin is going to start screen.

Shotting the dozens, the hundreds of faces on the zoom tiles,

taking one screenshot per page.

And then what we will do is stitch them

together in what looks like one massive zoom room,

even though it was originally multiple screens.

He's got some fancy artificial intelligence based

software that can detect your face,

your name and splice it all together into one big illusion of a massive

gallery.

I'm saying a lot of words just to get us to

the finish line and there we are now before we begin,

might a few people just like to say hello and

where you are in the world or what you're studying?

Just time for a few. But this will let us test the audio as well.

Let's see. Wrong shin will prompt. Let's see who here,

who do we have? How about Elena? Do you want to say hello first?

Hello Dave. My name is Elena. I'm from Ukraine Kiev

and thank you for the opportunity to study biting with you. Very cool. Thank you.

Well,

welcome and certainly hope this finds you and

your family and all of your friends faring.

Okay, right now welcome to the class. Uh someone else if we could say hello to

if I'm saying that. Right,

let's see

if you can hear me.

You seem to have throat.

Um

especial thanks to you. My name is

I'm Ellen and I'd like to build student

Welcome to the class as well. Welcome aboard.

How bout time for one or two more wrong shin,

let's see how about randomly over to the Darth if I'm saying that right

Yes, yes. Uh Good morning sir.

Uh Sir,

I am from India and I would like to tell you that you have a great fan base in India.

So please do visit India someday. And Namaste,

thank you.

Welcome to the class and thank you for the kind words,

how about one more Hello and I hope you'll forgive

if we don't get to all the raised hands,

but we got a lot of learning to do martin if you'd like to say hello next.

Yeah,

hello. Hello David. I'm from Germany.

I'm glad to be in your class today and normally I'm

studying digital transformation and global

entrepreneurship at the university here.

Nice. Well, welcome to CS 50 as well.

Well,

I hope you won't in mind indeed that we put the rest of the hands down in just a moment.

Today's lecture is going to be about something

called regular expressions if you're joining us for the

first time or one of the first few times and this feels like over your head,

not to worry you might just be joining late in the class,

but what we've been doing is filming multiple lectures at a time,

releasing them one at a time on the course's website

but so if you're here for the first time,

not to worry if it seems all too familiar or

uncomfortable if you go back and start from the beginning.

Um Quite surely you'll do

just fine. So give us just a minute or so to get reset over here.

Then I kind of come back and pretend like I'm seeing you

for the very first time again and we'll dive into today's topic.

It's just gonna be the one lecture on regular expressions.

So it'll be a little shorter than usual. But after that we'll do a little bit of Q and A.

And then we'll adjourn for the morning, afternoon or evening, be back in a moment.

Mhm.

All right. This is CS fifty's introduction to programming with python.

My name is David malin and this is our week on regular expressions.

So a regular expression otherwise known as a rejects is really just a pattern.

And indeed it's quite common in programming to want to

use patterns to match on some kind of data.

Often user input.

For instance if the user types in an email address,

whether to your program or a website or an app on your phone,

you might ideally want to be able to validate that.

They did indeed type in an email address and not something completely different.

So using regular expressions,

we're gonna have the newfound capability to define patterns in our code

to compare them against data that we're receiving from someone else,

whether it's just validated or heck,

even if we want to clean up a whole lot of data that itself might be

messy because it too came from us humans

before though we use these regular expressions.

Let me propose that we solve a few problems using just some

simpler syntax and see what kind of limitations we run up against.

Let me propose that I open up V. S.

Code here and let me create a file called validate dot pi.

The goal at hand being to validate.

How about just that a user's email address, they've come to your app,

they've come to your website,

they type in their email address and we want to say yes or no.

This email address looks valid.

Alright,

let me go ahead and type code of validate dot pi

to create a new tab here and then within this tab.

Let me go ahead and start writing some code.

How about that keeps things simple initially.

First let me go ahead and prompt the user for their email address

and I'll store the return value of input in a variable called email,

asking them what's your email question mark.

I'm gonna go ahead and preemptively at least clean

up the user's input a little bit by minimally just

calling strip at the end of my call to input

because recall that input returns a string or a stir

stirs come with some built in methods or functions one of which is strip which has the

effect of stripping off any leading whitespace to the

left or any trailing whitespace to the right.

So that's just gonna go ahead and at least avoid

the human having accidentally typed in a space character.

We're gonna throw it away just in case now I'm gonna do

something simple for a user's input to be an email address.

I think we can all agree that it's got a minimally have an AT sign somewhere in it.

So let's start simple.

If the user has typed in something with an at sign,

let's very generously just say okay valid looks like an

email address and if we're missing that at sign,

let's say invalid because clearly it's not an email address,

it's not gonna be the best version of my code yet.

But we'll start simple. So I'm gonna ask the question.

If there is an at symbol in the user's email address,

go ahead and print out for instance quote unquote valid

else. If there's not now, I'm pretty confident that the email address is in fact

invalid.

Now, what is this code doing?

Well, if at sign in email is a python,

IQ way of asking is this string quote unquote at in this other string email,

no matter where it is at the beginning the middle of the end,

it's going to automatically search through

the entire string for you automatically.

I could do this more verbose

and I could use a for loop or a while loop

and look at every character in the user's email address.

Looking to see if it's an at sign.

But this is one of the things that's nice about python, you can do more with less.

So just by saying if at quote unquote an email, we're achieving that same result.

We're gonna get back. True if it's somewhere in there.

Thus valid or false if it is not.

Well,

let me go ahead now and run this program in

my terminal window with python of validate dot pi.

And I'm gonna go ahead and give it my email address,

mailing at harvard dot edu you enter and indeed it's valid.

Looks valid is valid. But of course this program is technically broken. It's buggy.

What would be an example input. If someone might like to volunteer an answer here

that would be considered valid. But you and I know it really isn't valid.

Alright. This first version is just not so good just yet, Alex your thoughts.

Well, yeah. Thank you.

Well, pleased to second type just to sign science and visit and you'd still be valid.

Can still be violent according to your program. But

exactly we've set a very low bar here.

In fact,

if I go ahead and rerun python or validate dot pi and I'll just type in one ad sign.

That's it. No user name, no domain name.

This doesn't really look like an email address.

But unfortunately my code thinks that in fact is because

it's obviously just looking for an at sign alone.

Well, how could we improve this.

Well minimally an email address I I think tends

to have that this is not actually a requirement

tends to have an at sign and a single dot at least maybe somewhere in the domain name,

so malin at Harvard dot e d u.

So let's check for that dot as well.

Again, strictly speaking doesn't even have to be that case,

but I'm going for my own email address at least for now as our test case.

So let me go ahead and change my code now and say not only if at is an email

but also uh dot is an email as well.

So I'm asking now two questions I have to boolean expressions if at an email

and I'm ending them together logically this is a logical and so to speak.

So if it's the case that at is an email and dot is an email.

Okay, now I'm gonna go ahead and say valid.

Alright, this would still seem to work for my email address.

Let me go ahead and run python or validate dot pi malin at

harvard dot e d u enter and that of course is valid,

is expected but here too,

we can be a little adversarial and type

in something nonsensical like at dot and unfortunately

that too is going to be mistaken as valid even though there's still no user name,

domain name or anything like that.

So I think we need to be a little more methodical here. In fact

notice that if I do this like this,

the at sign can be anywhere and the dot can be anywhere.

But if I'm assuming the user is going to have a traditional domain name,

like Harvard dot e d U or gmail dot com.

I really want to look for the dot in the domain name only.

Not necessarily just the user name.

So let me go ahead and do this. Let me go ahead and introduce a bit more logic here.

And instead do this. Let me go ahead and do uh email dot split of quote unquote at sign.

So email again as a string or a stir stirs come

with methods not just strip but also another one called Split.

That is the name applies. Will split one stir into multiple ones.

If you give it a character or more to split on.

So this is hopefully going to return to

me two parts from a traditional email address,

the user name and the domain name.

And it turns out I can unpack that sequence of responses by doing this user name.

Comma domain equals this.

I could store it in a list or some other structure but if I already know

in advance what kinds of values I'm expecting a user name and hopefully a domain,

I'm gonna go ahead and do it like this instead and just defined two variables at once

on one line of code and now I'm going to be a little more precise if user name

uh if user name

then I'm gonna go ahead and say print valid

else, I'm gonna go ahead and say print invalid now, this isn't good enough.

But I'm at least checking for the presence of a user

name now and you might not have seen this before.

But if you simply ask a question, like if user name and user name is a string, well,

user name,

if user name is going to give me a true answer

if user name is anything except none or quote unquote nothing.

So there's a truth e value here whereby if user name has at least one character,

that's going to be considered true.

But if user name has no characters,

it's going to be considered a false value effectively.

But this isn't good enough. I don't want to just check for user name.

I want to also check that it's the case that dot is in the domain name as well.

So notice here there's a bit of potential confusion with the english language here.

I seem to be saying if user name and dot in domain as though I'm

asking the question if the user name and the dots are in the domain,

but that's not what this means.

These are two separate boolean expressions if user name and separately

if dot in domain and if I parenthesis eyes this,

we could make that even more clear by putting parentheses there parentheses here.

So just to be clear, it's really to boolean expressions that we're ending together,

not one longer english like sentence.

Now, if I go ahead and run this python of validate dot pi enter,

I'll do my own email address again, malin at harvard dot edu and that's valid.

And it looks like I could tolerate something like this.

If I do mail in at just say Harvard,

I think at the moment this is going to be invalid now.

Maybe the top level domain Harvard exists,

but at the moment it looks like we're looking for something more.

We're looking for a top level domain to like dot e d U.

So for now we'll just consider this to be invalid.

But it's not just that we want to do.

It's not just that we want to check for the presence

of a user name and the presence of a dot.

Let's be more specific.

Let's start to now narrow the scope of this program

not just to be about generic emails more generally,

but about e d u addresses.

So specifically for someone in US university for instance,

whose email address tends to end with dot e d u.

I can be a little more precise and you might recall this function

already instead of just saying is there are dots somewhere in domain,

let me instead say and the domain ends with quote unquote dot e d u.

So now we're being even more precise,

we want there to be minimally a user name that's not empty.

It's not just quote unquote nothing and we want the domain name to actually end with

dot e D U.

But could this be broken still looking at this version of my code?

Can someone think of an input that will break this version now

and it will consider the input to be valid even though it's not

any observations here. Gene if I'm saying it right

Hello, Can you hear me?

The

if the you fair name Oh yeah.

If the art sign is not, if the letter after the art sign is not present

if the letter of the at sign is where

if the if the letter R

if the facts are that block that I do you for example as

uh

in the chat if what if that works or if that didn't work.

Okay I had a little trouble hearing you but I know that your emphasis is on the at sign.

So let me try something along those lines.

Let me go ahead and run python and validate dot pi.

And just to make sure I haven't made things even worse.

Let me at least chest my own email address

which does seem to be valid

Now it seems that I minimally need to provide a user

name because we definitely do have that check in place.

So I'm gonna go ahead and say malin and now I'm

gonna go ahead and say ATS and it looks like I

could be a little malicious here just say malin at dot

e d u as though minimally meeting the requirements of this,

of this pattern and that of course is considered valid but I'm

pretty sure there's no one at malin at dot e d u.

We need to have some domain name in there.

So we're still not being quite as generous now,

we could absolutely continue to iterate on this program

and we could add some more bullying expressions.

We could maybe use some other python methods for checking more

precisely as there's something to the left of the dot,

to the right of the dot.

We could use split multiple times. But honestly this just escalates quickly.

Like you end up having to write a lot of code

just to express something that's relatively simple in spirit,

just format this like an email address.

So how can we go about improving this? Well, it turns out in python

there's a library

for regular expressions,

it's called succinctly r e and in the R e library you

have a lot of capabilities to define and check for and even replace

patterns again, a regular expression is a pattern.

And this library,

the ari library in python is gonna let us to define some of

these patterns like a pattern for an email address and then use some built

in functions to actually validate the user's input against that pattern or even use

these patterns to change the user's input

or extract partial information there from?

We'll see examples of all this and more.

So what can And should I do with this library?

Well, first and foremost it comes with a lot of functionality.

Here's the RL for instance to the official documentation.

And let me propose that we focus on using one

of the most versatile functions in the library library,

namely this search ari dot searches the name of the function in the

R E module that allows you to pass in a few arguments.

The first is gonna be a pattern that you want to search for in for instance,

a string that came from a user,

the string argument here is going to be the actual string that you

want to search for that pattern and then there's a third argument optionally,

that's a whole bunch of flags.

A flag in general is like a parameter.

You can pass in to modify the behavior of the function.

But initially we're not even going to use this,

we're just gonna pass in a couple of arguments instead.

So let me go ahead and employ this ari library,

this regular expression library and just improve on this design incrementally.

So we're not gonna solve this problem all

at once but we'll take some incremental steps.

I'm gonna go back to the S code here and I'm gonna go ahead now and get rid of most of

this code but I'm going to go into the top of

my file and first and fall import this ari library.

So import ari gives me access to that function. And more

now after I've gotten the user's input in the same

way as before stripping off any leading or trailing whitespace,

I'm just going to use this function Super trivially.

For now, even though this isn't really a big step forward,

I'm gonna say if ari dot search

contains quote unquote

at in the email address,

then let's go ahead and print valid

else. Let's go ahead and print invalid at the moment.

This is really no better than my very first version where I

was just asking python if at sign in the email address,

but now I'm at least beginning to use this library by using its own ari

dot search function which for now you can assume returns a true value effectively.

If indeed the at sign is an email just to

make sure that this version does work as I expect.

Let me go ahead and run python or validate dot pi and enter.

I'll type in my actual email address and we're back in business.

But of course this is not great because if I similarly run

this version of the program and just type in an at sign,

not an email address and yet my code of course thinks it is valid.

So how can I do better than this? Well, we need a bit more vocabulary

and the realm of regular expressions in order to be

able to express ourselves a little more precisely really.

The pattern I want to ultimately define is going to be

something like I want there to be something to the left,

then an at sign,

then something to the rights and that's something to the

right should end with dot e d u but should also

have something before the dot e d u like Harvard or

Yale or any other school in the US as well.

Well, how can I go about doing this?

Well, it turns out that in the world of regular expressions,

whether in python or a lot of other languages as well,

there's certain symbols that you can use to define patterns at the moment.

I've just used literal raw text.

If I go back to my code here,

this technically qualifies as a regular expression I've passed in

a quoted string inside of which is an at sign.

Now, that's not a very interesting pattern. It's just an at sign.

But it turns out that once you have access to

regular expressions or a library that offers that feature,

you can more powerfully express yourself as follows.

Let me reveal that the pattern that you passed ari dot search can

take a whole bunch of special symbols and here's just some of them

in the examples we're about to see in the patterns

were about to define here are the special symbols.

You can use a single period a dot to just represent any character except a new line,

a blank line.

So that is to say if I don't really care what

letters of the alphabet are in the user's user name.

I just want there to be one or more characters.

Uh, in the user's name, dot allows me to express a through Z,

uppercase and lowercase and a bunch of other letters as well.

Star is going to mean and single, asterisk, zero or more repetitions.

So if I say something star,

that means that I'm willing to accept either zero repetitions,

that is nothing at all Or more repetitions.

One or two or 3 or 300.

If you see a plus in my patterns, that's going to mean one or more repetitions.

That is to say there's got to be at least one character there,

one symbol and then there's optionally more after that

and then you can say zero or one repetition,

you can use a single question mark after a symbol and

that will say I want zero of this character or one.

But that's all I'll expect.

And then lastly, there's gonna be a way to specify a specific number of symbols.

If you use these curly braces and a number represented here

symbolically as m you can specify that you want em repetitions,

be it one or two or three or 300.

You can specify the number of repetitions yourself.

And if you want a range of repetitions,

like you want this few characters or this many characters,

you can use curly braces and two numbers inside called here, M and N.

Which would be a range of em through and repetitions. Now, what does all of this mean?

Well let me go back to V S code here and

let me propose that we iterate on this solution further.

It's not sufficient to just check for the at sign.

We know that already we minimally want something to the left and to the right,

so how can I represent that?

I don't really care what the users user name is

or what letters of the alphabet or in it,

be it malin or anyone else's.

So what I'm gonna do to the left of this equal sign is I'm going to

use a single period the dot that again indicates any character except for a new line,

but I don't just want a single character.

Otherwise the pierce person's user name could only be a

at such and such or be at such and such.

I wanted to be multiple such characters. So I'm going to initially use a star.

So dot star means give me something to the left and I'm gonna do another one.

Dot star something to the right. Now.

This isn't perfect but it's at least a step forward because

now what I'm gonna go ahead and do is this,

I'm gonna rerun python to validate deep.

I'm gonna keep testing my own email address just to

make sure I haven't made things worse and that's now.

Okay,

I'm now going to go ahead and type in some other input like how about just uh malin

at with no domain name whatsoever and you would

think this is gonna be invalid but but but

it's still considered valid

but why is that if I go back to this chart, why is malin at with no domain now

considered valid?

What's my mistake here

by having used dot star at dot star as my regular expression or reject

margarita

because you're using the star instead of the plus sign.

Exactly the star again means zero or more repetitions.

So Rory dot search is perfectly happy to accept nothing after

the after the at sign because that would be zero repetitions.

So I think I minimally need to evolve this and go back to my code

here and let me go ahead and change this from dot star two dot plus.

And let me change the ending from dot star two dot plus.

So that now when I run my code here,

let me go ahead and run python or validate dot

pi I'm gonna test my email address is always still

working now let me go ahead and type in that

same thing from before that was accidentally considered valid.

Now I hit enter finally it's invalid so now we're making some progress on

being a little more precise as to what it is we're doing now,

I'll note here, like with almost everything in programming, python included,

there's often multiple ways to solve the same problem.

And does anyone see away in my code here that I could make a slight tweak

if I forgot that the plus operator exists and go back to using a star.

If I allowed you only to use dots and only stars, could you recreate the notion of plus

yourself, Marshal?

Um Sorry? No, I accidentally that's okay. You're off the hook.

Someone else could I recreate this idea of one or

more repetitions by using just a star in no pluses,

Michael?

Yes. Um use another dot.

Yeah,

because if the dot means any character will just use a dot and then

when you want to say or more use another dot and then the star.

So equivalent to dot plus would have been dot dot star because

the first dot means any character and the second pair of characters,

dot star means zero or more other characters.

And to be clear, it does not have to be the same character.

Just by doing dot or dot star does not mean your whole user name needs to be a or a,

a or a a or a.

It can vary with each symbol, it just means zero or more of any character back to back.

So I could do this on both. The left and the right, which one is better.

You know, it depends,

I think an argument could be made that this is even

more clear because it's obvious now that there's a dot,

which means any character and then there's the dot star.

But if you're in the habit of doing this frequently,

one of the reasons things like the plus exist

is just to consolidate your code into something a little

more succinct and if you're familiar with seeing the

plus now maybe this is more readable to you.

So again, just like with python more generally,

you're gonna often see different ways to express the same patterns and

reasonable people might agree or disagree as to which way is better

then another.

Well, let me propose to that.

We can think about both of these models a little more graphically.

If this looks a little cryptic to you,

let me go ahead and rewind to the previous incarnation of this regular expression,

which was just a single dot star.

And let me go ahead and propose that you can think of this whole pattern as dot star at

dot star as really being some kind of flow similar

in spirit to our flow charts from weeks passed,

but this one is technically more of a state machine, so to speak.

This is a graphical representation of what really your code is

doing underneath the hood or what python is doing for you.

Um what we have here is a depiction of where the story begins,

it starts over here and if you think about a user's input,

what this state machine is going to do otherwise

known as a non deterministic finite automaton is,

it's going to read the user's input from left to right

and try to match it against this picture as well.

In other words,

this picture is equivalent to that same regular expression dot star at dot star.

And you can use this depiction as follows logically,

if you start over here on the left and

you start processing the user's input from left to right

this state.

This circle here in this circle

here represent technically different states that the

picture can be in and when you start here in this state,

notice that there's an arrow up and back down to the same state.

What that means is per the dot above that arrow,

you can consume one or two or three or four

or any number of characters from the user's input.

And if it's M a l a n, each of those is detected by way of this

placeholder,

this dot and so you can start consuming the user's input from left to right.

Then eventually though there's gonna have to be an at sign.

And so pictorially,

what happens is that the computer changes state into a

state whereby you have now read the at sign,

but after that you're welcome to read again and again and again and again,

any number of additional symbols.

And the fact that this circle here is a double circle, one bigger circle,

and then a smaller circle inside of it means that it's a an accept state.

A final state whereby the machine terminates having read the user's whole input.

By contrast, if we go back to my other version of the code where I instead had

dot plus on both the left and the right, you can think of.

This picture is looking a little different.

This one actually has more states and if you start here again and start

on the left and you start moving into this first state per the circle.

The first thing you might handle now is

minimally any character represented again by a dot.

Then you can rep then you can have any number of other symbols,

thereby following this loop here,

followed by an at sign followed by at least one

symbol followed by any other characters that you might want.

But this final state here on the right again is a double circle which means

the story ends there once you've gotten to the end of the user's input.

So what is the ari dot search function and functions like it doing

there essentially implementing that automaton.

It's a software based machine in this case

that's probably

the pattern and its implementing that pattern in some sense

in via that graphic by following the characters,

one at a time and making sure they not only match the pattern in V.

S code here, but that pattern depicted graphically as well.

Well, how can we go upon improving this code further?

Let me propose now that we check not only for

a user name and also something after the user name,

Like a domain name, but minimally required that the string ends with dot e d U as well.

Well, I think I could do this fairly straightforward.

Not only do I want there to be something

after the at sign like the domain like Harvard,

I want the whole thing to end with dot e D U,

but there's a little bit of danger here.

What have I done wrong by implementing my regular expression now in this way,

by using dot plus at dot plus dot e D U.

What could go wrong with this version?

Yeah, that's all I'm saying it right.

Yeah.

Uh,

the dot is and that means something else in this context where

it means there are more repetitions of character which is vitally interpreted.

President

exactly. Even though I mean for it to mean literally dot e d u a period and then dot e d u.

Unfortunately in the world of regular expressions, dot means any character,

which means that this string could technically end in a e d u

or B e D u or c e d u and so forth.

But that's not in fact that I want.

So any instincts now as to how I could fix this problem.

And let me demonstrate the problem more clearly.

Let me go ahead and run this code here.

Let me go ahead and type in malin at Harvard dot e d U.

And as always this does in fact work. But watch what happens here.

Let me go ahead and do malin at Harvard and then uh malin at Harvard question Mark, E D.

You enter

that too is valid.

So I could put any character there and it's still going to

be accepted but I don't want question mark E D U.

I want dot E D U literally

any instincts then for how we can solve this problem here.

How can I get this new function or re dot search?

And a regular expression more generally to literally mean a dot might you think

we've seen similar problems and similar solutions in the past?

Used to be if I'm saying it right,

I think we can stitch an extra string behind the plus. Not plus.

Yeah, not behind the dot plus.

We don't want the dot plus to be prefixed with

something but I think you're on the right track.

Other thoughts for how we can get a literal dot. You d you you go

you can use the escape character, the backslash. Indeed.

The so called escape character which we've seen

before outside of the context of regular expressions.

When we talked about new lines backslash. N was a way of telling the computer.

I want a new line but without actually literally hitting enter and moving

the cursor yourself and you don't want a literal end on the screen?

So backslash and was a way to escape and and convey that you want a new

line turns out regular expressions use a very

similar technique to solve this problem as well.

And so what I'm going to do here is exactly that

I'm gonna put a single backslash before the dot E D.

U. To make clear that I want literally a dot E D. U at the end of the string.

So that now when I rerun my code,

I think malin at harvard dot you do, you will still be considered valid.

And now if I run it again malin at Harvard question mark,

E D or any other character that's not a dot, thankfully.

Now this is considered invalid.

Any questions now on this technique for matching something to

the left of the at sign something to the right,

and now ending with dot e D U explicitly tell you.

Yeah. What happens then is that it has practical outside

a good question. You kind of called me out here.

Well when in doubt, let's try,

let me go ahead and do python to validate dot pi malin at at at Harvard dot e d U.

Which also is incorrect. Unfortunately, Michael thinks it's valid.

So another problem to solve but um shortcoming for now, other questions

on these regular expressions thus far,

actually,

yeah, can you use curly brackets and instead of backslash,

can you use curly brackets instead of backslash?

Not in this case if you want a literal dot backslash dot is the way to do it literally.

How about one other question on regular expressions?

Yeah. Over two

abuse.

Mm hmm.

Hi there. Can you hear me? We can. Yes.

All right. Um, so I've got two questions. Um,

so the could you just explain to me what the plus? Sorry, the plus does in this case

and um,

if I'm correct this, correct me if I'm wrong.

Is this the same thing that google forms uses in order to

um

categorize data, then let's say someone if you've got multiple people

sending in requests about some feedback,

do they categorize the data that they

get using this particular regular expression thing.

A good question. So let me take the first question first.

What exactly does this plus mean?

So if we go back from a moment ago to

our chart which defines each of these various symbols,

recall that dot means any character except a new line.

So that might mean a or B or C or it turns out the at sign.

So literally any character on your keyboard except a new line is

what dot represents A plus meanwhile represents one or more such characters.

So in the context of my actual code, if I go back here,

this dot at the beginning of my pattern means any character.

The plus sign means one or more of the previous thing.

So that means a or a or a or it doesn't have to be the same letter again and again,

it can be a or a B or a B, C.

It just means one or more characters is what dot plus means.

That's in contrast to dot star, which is zero or more characters,

which would mean nothing.

So no user name whatsoever or a user name of length one or two or three or anything else

In answer to your question about google forms.

Indeed, if you've ever used google forms to not just submit it,

but to create a google form,

one of the menu options is for response validation in english at least.

And what that allows you to do is specify that the user has to

input an email address or you are L or a string of some length,

but there's an even more powerful feature that some of you may not have ever noticed.

And indeed, if you'd like to open up google forms,

create a new form temporarily and poke around.

You will actually see in english at

least quote unquote regular expression mentioned as one

of the mechanisms you can use to validate your user's input into your google forms.

So in fact after today you can start avoiding the specific dropdowns

of like email address or you are L or the like,

and you can express your own patterns

precisely as well. Regular expressions can even be used in V. S code itself.

If you go and find or do a find and replace in V. S code.

You can of course just type in words like

you could into Microsoft word or google docs.

You can also type if you check the right box,

regular expressions and start searching for patterns, not literally

specific values.

Well,

let me propose that we now enhance this implementation further by

introducing a few other symbols because right now with my code,

I keep saying that I want my email address to end with dot E D U.

And start with the user name.

But I'm being a little too generous.

This does in fact work as expected from my own email address malin at Harvard dot e d u.

But what if I type in a sentence like my email address is malin at harvard dot

edu And suppose I've typed that into the program

or I've typed that into a google form.

Is this going to be considered valid

or invalid?

Well, let's consider. It's got the at sign. So we're good there.

It's got one or more characters to the left of the at sign.

It's got one or more characters to the right of the at sign. It's got a literal dot e D U.

Somewhere in there, to the right of the at sign.

And granted there's more stuff to the right,

there's literally this period at the end of my english sentence

but that's okay because at the moment,

my regular expression is not so precise as to say,

the pattern must start with the user name and end with the dot E D U.

Technically it's left unsaid.

What more can be to the left and what more can be to the right.

So when I hit enter now you'll see that that whole sentence

in english is valid and that's obviously not what you want.

In fact consider the case of using google forms

or Office 3 65 to collect data from users.

If you don't validate your input,

your users might very well type in a full

sentence or something else with a typographical error,

not an actual email.

So if you're just trying to copy all of the results that have been typed

into your form so you can paste them into gmail or some email program,

it's gonna break because you're gonna accidentally pay

something like a whole english sentence into the program

instead of just an email address, which is what your mailer expects.

So how can I be more precise?

Well, let me propose, we introduce a few more symbols as well.

It turns out in the context of a regular expression.

One of these patterns, you can use the carrot symbol,

the little triangular mark to represent that.

You want this pattern to match the start of the string specifically.

Not anywhere, but the start of the user string.

By contrast,

you can use a dollar sign in your regular expression to say that you want to match the

end of the string or technically just before the new line at the end of the string.

But for all intents and purposes think of carrot as meaning start

of the string and dollar sign is meaning end of the string.

It is a weird thing that one is a carrot and one is a dollar sign.

These are not really things that I think of

as opposites like a parenthesis or something like that,

but those are the symbols the world chose many years ago.

So let me go back to V. S. Code now and let me add this feature to my code here.

Let me specify that yes,

I do want to search for this pattern but I want the user's input

to start with this pattern and end with this pattern.

So even though it's gonna start looking even more cryptic,

I put a carrot symbol here at the beginning and I put a dollar sign here at the end.

That does not mean I want the user to type a caret symbol or a dollar sign.

This is special symbology that indicates to ari dot search

that it should only look for now an exact match against this pattern.

So if I now go back to my terminal window

and I'll leave the previous result on the screen.

Let me type the exact same thing, my email addresses mailing at harvard dot edu.

You enter,

sorry period and now I'm gonna go ahead and hit enter now that's considered invalid.

But let me clear the screen and just to make sure I didn't break things,

let me type in just my email address

and that too is valid.

Any questions now on this version

of my regular expression

which note goes further to specify even more

precisely that I wanted to match at the start

and the end.

Any questions on this one here?

Yeah. Mammy nana. I'm sorry if I'm saying that wrong.

Yeah you got it right. So my question is after the slash. You have that E. D. U.

And then the dollar sign.

But what how how does the slash separate the dot from before the U.

And the dot after it. You

the slash. Okay so let me focus. You want to say it again.

Uh

I mean okay you have slash and that video and then the dollar sign.

But that is like one of the regular expression. Right?

It normally is but this backslash that I deliberately

put before this period here is an escape character.

It is a way of telling ari dot search that I don't want any character there.

I literally want a period there and it's the

only way you can distinguish one from the other.

If I got rid of that slash this would mean that the email

address just has to end with any character than any then A.

D. Then a. You I don't want that. I want literally a period then the E. Then the D.

Than the U.

Okay. So we don't need another. Oh sorry sorry.

This is actually common convention in programming and technology in general.

If you and I decide on a convention whereby we're

using some character on the keyboard to mean something special.

Invariably we create a future problem for ourselves when

we want to literally use that same character.

And so the solution in general to that problem is to somehow escape the

character so that it's clear to the computer that it's not that special symbol.

It's literally the symbol it sees. And yes back to you for a question.

Okay,

so we don't even know that we don't

need another another slash before the dollars time.

No because in this case dollar sign means something special per this chart here,

dollar sign by itself does not mean us dollars or currency.

It literally means match the end of the string.

If however I wanted the user to literally type in

a dollar sign at the end of their input.

The solution would be the same.

I would put a backslash before the dollar sign which means my email

address would have to be something like malin at Harvard dot E.

D. U.

Dollar sign which is obviously not correct to so backslash

is just allow you to tell the computer to not treat

those symbols specially likes meaning something special but to treat

them literally instead about one other question here on regular expressions

uh Yeah, let's say trey if I'm saying it right

I got a question about oh you took it down,

there was a period and then there was another one.

You said you took one off and then you added one. Why was that?

And then added one,

there's a

in the period

uh so this before when I got rid of the backslash

or something else you said that one represents to make it one plus

and then you said one was to make it one with nothing.

Sure. Let me rewind in time.

I think what you're referring to was one of our earlier versions that initially

looked like this which just meant zero or more characters than an at sign

Than zero or more other characters.

We then evolved that to be this dot plus on both sides,

which means one or more characters on the left than an at sign,

then one or more characters on the right.

And if I'm interpreting your question correctly,

one of the points I made earlier was that if

you didn't use plus or forgot that it exists,

you could equivalently achieve the exact same result with two dots and a star

because the first dot means any character, it's got to be there.

The second dot star means zero or more other characters and same on the right.

So it's just another way of expressing the same idea.

One or more can be represented like this with dot dot star

or you can just use the handier syntax of dot plus, which means the same thing.

Did I interpret your question? Right?

I think you froze on us but

trey if you can hear me if that wasn't the answer to your question.

Just a message in the chat to carter and will field it again.

All right,

well let me propose that we should really be able to do even better than this.

Not just checking. Let me rewind to where we left off.

Well,

let me propose that we improve even upon this version here

because it turns out that we still have some bugs right?

It's still the case that I am allowed to have multiple at signs

in my input but that's not really in a valid email address.

In fact if I do this again,

python to validate dot pi and I do malin at at at harvard dot edu.

That shouldn't be valid.

No one you know has an email address that looks like that but my program.

Sorry,

sorry I broke something. Oh sorry I broke it.

Um

It's better.

Really?

What's that? Oh the dollar sign.

Sorry let's rewind. Alright.

All the questions made me break the code. Alright, but that's good.

Alright,

let me rewind to where we just were because I got confused for a second and you

can't hear him but carter secretly whispered the solution

to me there So thank you to carter.

Alright,

so I dare say there's still some problems with the regular expression in this

current form because even though now we're starting to look for the user name

at the beginning of the string from the user and we're looking for the

dot e d U literally at the end of the string from the user.

Those dots are a little too encompassing. Right now.

I am allowed to type in more than the single at sign. Why?

Because at is a character and dot means any character.

So honestly I can have as many at signs. Is this thing at the moment as I want.

For instance,

if I run python to validate dot pi mainland at

Harvard dot e d u still works as expected.

But if I also run python to validate dot pi

and incorrectly do mainland at Harvard dot e d U.

That should be invalid but

it's considered valid instead.

So I think we need to be a little more restrictive when it comes to

that dot and we can't just say oh any old character there is fine.

We need to be more specific.

Well it turns out that regular expressions also supports this syntax.

You can use square brackets inside of your pattern

and inside of those square brackets

include one or more characters that you want to look for specifically.

Alternatively you can inside of those square brackets.

Put a carrot symbol which unfortunately in this context means

something completely different from match the start of the string.

But this would be the compliments operator inside of these square brackets,

which means you cannot match any of these characters.

So things are about to look even more cryptic now,

but that's why we're focusing on regular expressions on their own here.

If I don't want to allow any character, which is what a dot is, let me go ahead.

And I could just say, well I only want to support A or B, Bs or CS or Ds or Ds or Fs or Gs.

I could type in the whole alphabet here.

Plus some numbers to actually include all of the letters that I do want to allow.

But honestly a little simpler would be this.

I could use a carrot symbol and then then at sign which has the effect

of saying this is the set of characters that has everything except an at sign.

And I can do the same thing over here instead of a dot,

to the right of the at sign. I can do open bracket

carrot at sign

and I admit things are starting to escalate quickly here.

But let's start from the left and go to the right.

This carrot outside of the square brackets at the very start of my string as before

means match from the start of the string and let's jump ahead the dollar sign.

All the way at the end of the regular expression means match at the end of the string.

So if we can mentally take those office straightforward,

let's now focus on everything else in the middle.

Well to the left here we have new syntax, a square bracket,

another carrot, an at sign and a closed square bracket. And then a plus.

The plus means the same thing as always. It means one or more of the things to the left.

What is the thing to the left? Well this is the new syntax inside of square brackets.

Here I have a carrot symbol and then an at sign

that just means any character except an at sign.

It's a weird syntax but this is how we can express that simple idea,

any character on the keyboard except for an at sign and heck even

other characters that aren't physically on

your keyboard but that nonetheless exist.

Then we have a literal at sign.

Then we have another one of these same things square bracket,

carrot at close bracket which means any character except an at sign.

Then one or more of those things followed by literally a period E D U.

So now let me go ahead and do this again.

Let me rerun python to validate dot pi and test my

own email address to make sure I've not made things worse.

And we're good. Now let me go ahead and clear my

let's fix this again.

Now let me go ahead and clear my screen and run python to

validate dot pi again and do malin at at at Harvard dot edu.

You crossing my fingers this time.

And finally this now is invalid why I'm allowing myself to

have one at sign in the middle of the user's input.

But everything to the left per this new syntax cannot be an at sign.

It can be anything but one or more times

and everything to the right of the at sign could

be anything but an at sign one or more times followed by lastly a literal dot E D U.

So again,

the new syntax is quite simply this square brackets allow you to specify

a set of characters that you literally type out at your keyboard,

A B c d E F or the compliment?

The opposite

the caret symbol which means not. And then the one or more symbols you want to exclude

questions.

Now on this syntax here of having a set of characters

or complementing the set that is taking the opposite Vishal.

Hi, am I audible? Good, thank you.

Uh I am an article. Yes you are.

Okay. Okay. So can we not use the

records and inside that. Can we not put one?

Because I think that would be more concise. Uh so you told us about the symbol.

That curly bracket and we can tell how many reputations we want to have.

So right after the at sign, can we use the curly brackets and one

so that we can only have one reputation of the example? Absolutely.

Let me rewind slightly just to make the example simpler for just a moment.

Back when we had this example here dot star at dot star,

I propose that we could make that one or more characters to

the left and the right or we could just use pluses instead.

You could absolutely do something like

oh sorry,

let me do that again.

Thank you.

Let's do this.

We have to do some movie magic here. Now, I'm gonna go over there. Absolutely.

So we could do this. Let me go ahead and pull a V.

S code and let me delete the current form of a regular expression and go

back to where we began which was just dot star at and dot star,

I could absolutely do something like this and require

that I want at least one of any character here

and then I could do something more to have anymore as well.

So the curly brace syntax,

which we saw on the slide earlier but didn't yet use

Absolutely can be used to specify a specific number of characters,

but honestly this is more verbose than is necessary.

The best solution arguably,

or the simplest at least ultimately is just to say dot plus

but there to another example of how you can solve the same problem

multiple ways.

Let me go back to where the regular expression

just was and take other questions as well,

questions on the sets of characters or complementing

that's set

Yeah. Angela Anjali,

Yeah. Hi, can you hear me?

So can you use that same syntax to say that

you don't want a certain character throughout the whole string?

You could it's going to be uh you could absolutely use the same character to exclude.

Um

you can absolutely use this in text to

exclude a certain character from the entire string.

But it would be a little harder right now because

we're still requiring dot E D U at the end.

But yes, absolutely.

Other questions

Sulaiman if I'm saying it right?

Yeah. I was wondering

what happens if the user in

e U. In the beginning of the thing. A good question.

What happens if the user types in dot e d U at the beginning

of the screen will let me go back to the s code here.

And let's try to solve this in two different ways.

First,

let's look at the regular expression and see if

we can infer if that's going to be tolerated.

Well, according to the current

cryptic regular expression,

I'm saying that you can have any character except the at sign.

So that would work. I could have the dot for the dot E D U.

But then I have to have an at sign.

So that wouldn't really work because if I'm just typing in dot E D U.

We're not going to pass that constraint. So now let me try this.

And by running the program, let me type in just literally dot e D U. That doesn't work.

But but but I could do this dot e D U at dot e D U. That too is invalid.

But let me do this uh dot e D U at something dot e D U that passes.

So it's starting to get a little weird now, maybe it's valid. Maybe it's not.

But I think we'll eventually be more precise to

about one more question on

this regular expression

and he's complimenting of sets vinnie back

if I'm saying it. Right,

Yes. Can we use another domain name?

They're stringing good.

Can you use another domain name? Absolutely.

I'm using my own just for the sake of demonstration,

but you can absolutely use any domain or top level domain and I'm using dot e D U.

Which is very us centric.

But this would absolutely work exactly the same for any top level domain.

All right, well, let me propose now that we enhance this all the further.

Sorry, give me a moment.

Okay,

we're gonna do a little more movie magic here.

All right, thank you for humoring us.

Alright,

let me go ahead now and propose that we improve this regular expression

further because if I pull it up again in Latvia's code here.

You'll see that I'm being a little too tolerant.

Still,

it turns out that there are certain requirements for someone's

user name and domain name in an email address.

There is an official standard in the world for what an

email address can be and what characters can be in it.

And this is way too accommodating of all the

characters in the world except for the at symbol.

So let's actually narrow the definition of what

we're going to tolerate in user names.

And companies like Gmail could certainly do this as well.

Suppose that it's not just that I want to exclude at sign.

Suppose that I only want to allow for say characters

that normally appear in words like letters of the alphabet,

A through Z.

B in uppercase or lowercase.

Maybe some numbers and heck, maybe even an underscore could be allowed to.

Well we can use this same square bracket syntax

to specify a set of characters as follows.

I could do a B C D E F G H I J. Oh my God, this is gonna take forever.

I'm gonna have to type out all 26 letters of the alphabet,

both lowercase and uppercase.

So let me stop doing that. There's a better way already.

If you want to specify within these square brackets a range of letters,

you can actually just do a hyphen if you

literally do a hyphen Z in these square brackets.

The computer is going to know you mean a through Z.

you do not need to type 26 letters of the alphabet

if you want to include uppercase letters as well, you just do the same.

No spaces, no commas, you literally just keep typing a through capital Z.

So I have little A hyphen little Z, big A hyphen big Z.

No spaces, no commas, no separators. You just keep specifying those ranges.

If I additionally want numbers, I could do 01234.

No, you don't need to type in all 10 decimal digits.

You can just say zero through nine using a hyphen as well.

And if you now want to support underscores as well,

which is pretty common in user names for email addresses,

you can literally just type an underscore at the at the end

notice that all of these characters are inside of square brackets,

which just again means here is a set of characters that I want to allow.

I have not used a carrot symbol at the beginning of this whole

thing because I don't want to complement it complemented with an e,

not complement it with an eye.

I want don't want to complement it by making it the opposite.

I literally want to accept only these characters.

I'm gonna go ahead and do the same thing on the right if I want to require that.

The domain names similarly come from this set of characters which

admittedly is a little too narrow but it's familiar for now.

So we'll keep it simple.

I'm gonna go ahead and paste that exact same

set of characters over there to the right.

And so now it's much more restrictive.

Now, I'm gonna go ahead and run python and validate dot pi.

I'm gonna test my own email address and we're still good.

I'm gonna clear my screen and run it once more this time trying to break it.

Let me go ahead and do something like how about David underscore malin

at harvard dot edu You enter but that too is going to be valid

but if I do something completely wrong again, like malin at at at harvard dot edu,

that's still going to be invalid.

Why?

Because my regular expression currently only allows for a single at

in the middle because everything to the left must be alpha,

numeric, alphabetical or numeric or an underscore the same thing to the right,

followed by the dot e d U.

Now, honestly,

this is a regular expression that you might be in the habit of

typing in the real world as in as cryptic as this might look,

this is the world of regular expressions so you'll

get more comfortable with this syntax over time.

But thankfully some of these patterns are so common

that there are built in shortcuts for representing some of the same information

that is to say you don't have to constantly type out all of the symbols that

you want to include because odds are some other programmer has had the same problem.

So built into regular expressions themselves

or some additional patterns you can use

and in fact I can go ahead and get rid of this entire set

a through Z. Lowercase a through Z. Uppercase zero through nine.

And an underscore and just replace it with a single backslash W

backslash W.

In this case represents a word character which is commonly known

as a alpha numeric symbol or the underscore as well.

I'm gonna do the same thing over here.

I'm going to highlight the entire set of square brackets,

delete it and replace it with a single backslash W.

And now I feel like we're making progress because even though it's

cryptic and what if it looked way cryptic a little bit ago?

Um

and even though it would have looked even more cryptic a little bit ago now,

it's at least starting to read a little more friendly.

This carrot on the left means start matching

at the beginning of the string backslash,

W means any word character.

The plus means one or more at symbol literally.

Then another word character,

one or more than a literal dot than literally e d U and

then match at the very end of the string and that's it.

So there's more of these two and we won't use them all here.

But here is a partial list of the patterns

you can use within a regular expression one.

You have backslash D. For any decimal digit decimal digit meaning zero through nine

commonly done here too is if you want to do the opposite of that, the compliment,

so to speak.

You can do back slash capital D. Which is anything that's not a decimal digits.

So it might be letters and punctuation and other symbols as well.

Meanwhile backslash s means white space characters,

like a single hit of the space or maybe hitting tab on the keyboard.

That's white space back slash capital S is the opposite or complement of that?

Anything that's not a whitespace character backslash

W We've seen a word character as well

as numbers and the underscore and if you want the compliment or opposite of that,

you can use backslash capital W to give you everything but a word character.

Again,

these are just common patterns that so many

people were presumably using in yesteryear that it's now

baked into the regular expression syntax so that

you can more succinctly express your same ideas.

Any questions then on this approach here where we're now using backslash W

to represent my word character.

Yeah, about over two

uh bunch I'm saying it right?

Oh you're muted and zoom but we don't hear you.

There we go.

Yeah.

Uh so I want to ask about was the actually the previous approach,

like the square bracket approach.

Could we accept like lists in there I suppose? Like if you want to go dot E D.

U and afterwards uh it was dot gmail or something like that.

Could you accept lists in there,

you can you can have multiple possible matches within your same string?

Let me see if I can find um this for you?

Arched?

Yes, we'll see this before long.

But suppose you wanted to tolerate not just dot e d U, but maybe dot e d u or dot com.

You could do this,

you could introduce parentheses and then you can or those together.

I could say calm or E D u.

I could also add in something like in the US or gov or net or anything else or.

Org or the like. And each of the vertical bars here means something special.

It means or and the parentheses simply group things together formally.

You have this syntax here. A or B.

A or vertical barbie means A has to match or B has to match

where A and B can be any other patterns you want in parentheses,

you can group those things together.

So just like math,

you can combine ideas into one phrase and do this thing or the other.

Um And there's other syntax as well that we'll soon see

other questions on these regular expressions and this syntax here.

Yeah. Let's go to uh horseshit if I'm saying it. Right.

Uh Yeah, I just want to ask our space is bound to a character or a function

or are they just valued?

Say that once more space is just what if we put spaces in the expression?

What if you want spaces in the expression?

I just wondered for the readability of the code, not in the input by the user.

Will they break the code or will they be just accepted? Sure.

So if you want spaces in there,

you can't use backslash W alone because that is only

a word character which is alphabetical numerical or the underscore.

But you could do this,

you could go back to this approach whereby you use square brackets and you could

say a through Z or a through Z or zero through nine or underscore.

Or I'm gonna hit the space bar a single space.

You can put a literal space inside of the square

brackets which will allow you then to detect a space.

Alternatively, I could still use backslash W but I could combine it as follows.

I could say give me a backslash W or a

backslash S because recall that backslash s is white space.

So it's even more than a single space. It could be a tab.

But by putting those things in parentheses now,

you can match either the thing on the left or the thing on the right one or more times.

How about one other question on these regular expressions?

Yeah, yoga.

Hi, can you guys hear me?

Perfect. So I was gonna ask does the backslash w um include a dot?

Because you know, it only includes letters, numbers

and underscore that is it.

And I was wondering you gave an example at the beginning that had uh spaces like

this is my email so and so um I don't think our current version even quite,

quite a long while ago stopped accepting it was that because of the carrot or

no. The reason I was handling spaces and other english words.

When I typed out my email addresses,

mailing at Harvard dot edu was because we were using

initially dot star or dot plus which is any character.

Uh And even after that we said anything except the at sign which includes spaces.

Only once I started using square brackets and a through Z and zero through nine.

And underscore did we finally get to the point where we would

reject white space and in fact I can run this here.

Let me go into the current version of my code in V.

S code which is using again the backslash w is for word characters.

Let me run python to validate dot pi and incorrectly type in something like

my email address is malin at harvard dot edu you period which has spaces to the left

of my user name and that is now invalid because space is not a word character.

Yorgo notes to that technically I'm not allowing dots and

some of you might be thinking wait a minute.

My gmail address has a dot in it.

That's something we're gonna still have to fix the

backslash W is not the end all here.

It's just allowing us to express our previous solution a little more succinctly

now, suppose that we want to improve on this further.

One thing we're still not handling well

is uppercase versus lower case necessarily.

Uh Yeah.

Now one thing we're still not handling

quite properly is uppercase versus lower case.

The backslash W technically does handle lower case letters and uppercase

because it's the exact same thing as that set from before,

which had little A through little Z and big A through big Z.

But watch this,

let me go ahead in my current form run python to validate dot pi And just because

my caps lock key is down malin at Harvard dot E D U shouting my email address.

It's gonna be okay in terms of the mail in,

it's gonna be okay in terms of the

Harvard because those are matching the backslash W.

Which does include lowercase and uppercase but I'm about to see invalid

why why is malin at Harvard dot E D U

invalid

when it's in all caps here. Even though I'm using backslash W

abe your thoughts?

Yeah.

So you are asking for the domain dot E D U

in lower case and you're typing in your upper kits?

Exactly. I'm typing in my email address in all uppercase.

But I'm looking for literally dot E D U.

And as I see you with airpods and so many of you with headphones.

I apologize for yelling into my microphone just now to make this point.

But let's see if we can't fix that. Well, if my pattern on line five is expecting

it to be lower case.

There's actually a few ways I can solve

this one would be something we've seen before.

I could just force the user's input to all lower case

and I could put onto the end of my first line.

Dot, lower and actually force it all to lowercase.

Alternatively, I could do that a little later.

Instead of passing an email,

I could pass in the lower case version of email

because email addresses should in fact be case insensitive,

so that would work too.

But there's another mechanism here which is worth seeing.

It turns out that that function before

called R e dot search

supports recall a third argument as well.

These so called flags and flags are configuration options typically to

a function that allow you to configure it a little differently.

And how might I go about configuring this call to ari dot search

a little bit differently insofar as I'm currently only passing into arguments.

Well, it turns out that some of the flags you can pass into this function are these,

it turns out that the regular expression library in python, a k a r e

comes with a few built in variables, so to speak,

things that you can think of as constants

that have meaning to ari dot search and they do so as follows.

If you pass in as a flag, ari dot ignore case.

What ari dot search is going to do is ignore the case of the user's input.

It can be uppercase,

lowercase a combination there of the case is going to be ignored.

It will be treated case insensitively and you can

do other things too that we won't do here,

but if you want to handle the user's input that maybe spans multiple lines,

maybe they didn't just type in an email address but an entire paragraph

of text and you want to match different lines of that text.

That is multiple lines.

Another flag is for ari dot multi line for just that or ari dot all whereby you can

can you can configure the dot to report to

recognize not just any character except new lines,

but any character plus new lines as well.

But for now let me go ahead and just make use of this first one.

Let me pass in the third argument to ari dot search which is ari dot uh ignore case.

And now let me rerun this without clearing my screen.

I'll again shout malin at harvard dot e d u

Let me do this again.

Sorry. Uh

now I have to fix that,

apologies. Let me fix this for the video.

Let me now rerun the program without clearing my screen python or

validate dot pi let me type in again in all caps,

effectively shouting malin at harvard dot edu you

enter and now it's considered valid because I'm telling

ari dot search specifically to ignore the case of the input and that too here is fine.

And why might I do this approach rather than

call dot lower in one of those other locations?

If I don't actually want to change the user's input for whatever reason,

I can still treat it case insensitively without

actually changing the value of that variable itself.

Are any final questions now on this validation of email addresses?

Any final questions? I'm just gonna make a fix here before we proceed.

Be right with you.

Okay? Yes, thank you for waiting alone or alan

mhm

can you hear me? Yes. What question do you have? So the pattern is a string. Right?

Can we use an F strength?

Can you use an F string technically.

No, no. Hmm.

I don't know actually you can okay, I'm secretly talking to carter.

You can yes,

you can use an F string so that you could plug in for

instance the value of a variable and pass it into the function?

I hope I hope I said my newfound knowledge with confidence.

Other questions on this pocket,

like access that look like could we take it as an input from the user?

Could you take the backslash w from the user?

Yes,

technically. Yes, that's not a problem we're trying to solve right now.

We want the user to provide literal input. Like their email address.

Not necessarily a regular expression,

but you can imagine building software that asks

the user especially if they're more advanced users

to type in a regular expression for some

reason to validate something else against that.

And in fact, that's what google is doing.

If you play around with google forms and create

a form with response validation and select regular expression.

Google, let's you. And I type in our own regular expressions would be a perfect.

Which would be a perfect example of that.

How about one final question on these regular expressions

and then we'll introduce a few more features as well. GTO if I'm saying it. Right.

Hello, can you hear?

Yes,

we can uh with this approach with backslash W If you're

our user inside an A I mean semini original educator,

this would be considered a value

in May. Right?

So long as the user types a word character, like a letter of the alphabet, A through Z,

a number like zero through nine or an

underscore backslash W Plus will recognize their input

if they type in a period or any other symbol function nation at the moment,

it will be rejected.

So it might not be a perfect rejects just yet.

All right, well, let me propose to here.

Alright, Give Me 1 2nd.

Alright, let's do this again.

All right, Well,

let me propose that we try to solve one other problem

here whereby if I go into the same version as before,

which is now ignoring case.

But I type in one of my other email addresses.

Let me go ahead and run python and validate dot pi and this time

let me type in not malin at harvard dot edu which I use primarily,

but another email address of mind mailing at CS 50 dot

Harvard dot e d u which forwards to the same.

Let me go ahead and hit enter now and uh huh invalid.

Even though I'm pretty sure that is in fact my email address.

Well let's put our finger on the reason why why at

the moment is mailing at CS 50 dot harvard dot edu.

You being considered invalid?

Even though I'm pretty sure I send and receive email from that address to

why might that be?

Yeah,

yeah, because there is a dot

that has come after the at symbol.

Exactly. There's a dot after my CS 50 and I'm not expecting any dots there.

I'm expecting only again.

Word characters, which is a through Z,

zero through nine and underscore so I'm gonna have to retool here.

But how could I go about doing this?

Well,

it turns out theoretically there could be other email addresses

even though they'd be getting a little excessively long.

For instance malin at something dot CS 50 dot

Harvard dot edu which is not technically exist,

but it could you can have of course multiple dots in a domain name like we see here,

wouldn't it be nice if we could handle that as well?

Well, let me propose that we modified my regular expression as follows.

It turns out that you can group ideas together and you can not only ask

whether or not this pattern matches or this one using syntax like a vertical bar,

B which means either A or B.

You can also group things together and then

apply some other operator to them as well.

In fact, let me go back to V.

S code here and let me propose that if I want to tolerate

a sub domain like CS 50 that may or may not be there.

Let me go ahead and change it as follows.

I could naively do this if I want to support

sub domains I could say well let's allow for other

word characters plus and then a literal dot and notice

I'll highlight in blue here what I've just added.

Everything else is the same but I'm now adding room for another

sequence of one or more word characters and then a literal dot.

So this Now I think

if I rerun python to validate dot pi will work for malin at CS 50 dot Harvard dot edu.

You enter unfortunately. Does anyone see where this is going?

Let me rerun python to validate dot pi and type in as I keep doing malin

at harvard dot edu which up until now has kept working despite all of my changes.

But now

finally I've broken my own email address

so logically. What's the solution here?

Well, there's a bunch of ways we could solve this.

I could maybe start using two regular expressions

and support your email addresses of the form,

user name at domain dot t l D or user name at sub domain dot domain dot t l D.

Where T LD just means top level domain like E d U.

Or I could maybe just modify this one because I'd prefer not

to have like two regular expressions or one that's twice as big.

Why don't I just specify to ari dot search that part of this pattern is optional.

What was the symbol we saw earlier that allows you

to specify that the thing before it is technically optional.

Can anyone recall what symbol we could use to

effectively represent that something before it is optional.

Daniel your thoughts.

Oh, the straight bar. We are using the straight bar as um optional.

Make the the argument optional.

So we could we could use a vertical bar and some parentheses and say

either there's something here or there's nothing we could do that in parentheses.

But I think there's actually an even easier way.

How can I specify that? What I've highlighted in blue? The new backslash w plus

backslash dot is technically optional. It can either be there or not, Philip

actually. It's a question mark.

Indeed, question mark.

Think back to this summary here of our first

set of symbols whereby we had not just dot and

star and plus but also a question mark which means

literally zero or one repetitions which effectively means optional.

It's either they're one or it's not zero.

Now how can I translate to that to this code here?

Well let me go ahead and surround this part of my pattern with

parentheses which doesn't mean I want literally a parenthesis in the user's input.

I just want to group these characters together and in fact this now will still work.

I've only added parentheses around the new part for the sub domain.

Let me run python to validate dot pi.

Let me run mainland at CS 50 dot Harvard dot you do

you enter that's still valid but to be clear if I rerun it

again for malin at Harvard dot edu you that is still invalid

but not if I go in here and say after the parentheses,

which now is one logical unit.

It's one big group of ideas together. I add a single question mark there.

This will now tell ari dot search that that whole

thing in parentheses can either be there once or B.

They're not at all. Zero times. So what does this translate into when I run it?

Well let me go ahead and rerun it with mainland at CS 50 dot

harvard dot edu you so that the sub domains there that works as before.

Let me clear my screen and run it again python to validate dot

pi with malin at Harvard dot edu which used to work then broke

is are we back in business now? We are. That's now valid again.

Questions now on this approach where we've used not just the

question mark

but the parentheses as well.

Yeah.

Okay. Yeah. You said it works for zero or 1 repetition. What if you have more?

What if you have more? That's okay.

That's where you could do Star star is zero or

more which gives you all the flexibility in the world.

Good question. Others on Nikita

not yet. Still muted

in zoom. You're muted. You'll have to click the there we go.

Yeah. Can you hear me? Yes.

Yeah. So I was just asking that with question marks.

There's only one repetition allowed.

It means zero or 1 repetition. So it's either not there or it is there.

And so that's why this pattern now if I go back

to my code even though again it admittedly looks cryptic.

Let me highlight everything after the at sign and before the dollar sign.

This now represents a domain name like Harvard dot you do you?

Or a sub domain within the domain name. Why will this part to the right

is the same as always backslash. W plus means something like Harvard or Yale

backslash dot e D U means literally dot e D U.

So the new part is this in parentheses I have

another set of backslash W plus backslash dot now.

But it's all in parentheses.

I'm now having any question mark right after that which

means that whole thing in parentheses either can be there

or it can't be there. It's either of those that are acceptable.

So a question mark effectively make something optional.

It would not be correct to remove the parentheses because what would this mean

if I remove the parentheses, that would mean that only this dot is optional.

Which isn't really what we want to express.

I want the sub domain like CS 50 and the additional dot

to be what's there or not there?

About one other question on

red taxes here. Priscilla.

Um

Hi, can you hear me? Yes we can.

Hi. How are you?

Can they use this for the user names?

It's like my my user name is pre dot Ilya.

Absolutely, absolutely. We still have other problems. Right.

We're not solving all the problems today just yet but absolutely. Right now.

We are not letting you have a period in your user name.

And again some of you with gmail accounts or other

accounts you probably have not just underscores numbers and letters.

You might have periods to well we could fix that.

Not using question mark here per se.

But now that we have these parentheses at our disposal,

what I could do is this I could use parentheses to surround the backslash W to say any

word character which is the same thing again as a letter or a number or an underscore.

But I could also, or in using a vertical bar something else like a literal dot.

Now a literal dot needs to be escaped.

Otherwise it represents any character which would be a regression a step back.

But now notice what I've done in parentheses.

I'm telling ari dot search that those first few characters in

your email address that is your user name has to be

a word character like a through Z uppercase or lowercase or

zero through nine or an underscore or a literal dot.

We could do this differently to I could get rid of the parentheses

and the ore and I could just use a set of characters.

I could again manually say a through Z, a through Z0 through nine

underscore and then I could do a literal dot with a backslash period And now I

technically don't even need the upper case because

I'm already telling the computer to ignore case.

I can just pick one or the other. Which one is better is really up to you.

Whichever one you think is more readable would generally be the better design.

All right, let me propose

that I rewind this in time to where we left off

which was here.

And let me propose that there are indeed still limitations of this solution,

not just with the user name,

not just with the domain name were still being a little too restrictive.

So would you like to see the official

regular expression that at least browsers use nowadays

whenever you type in an email address to a web form and the web form,

the browser tells you yes or no. Your email address is sint tactically valid.

Ready.

Ready

here is and this isn't even officially the right regular expression.

It's a simplified version that browsers use because

it catches most mistakes but not all.

Here we go.

This is the regular expression for a valid email address.

At least as browsers nowadays implement them now.

It's crazy,

cryptic at first glance but note and it's wrapping

on too many lines but it's just one pattern.

But just notice the now familiar symbols there is the carrot symbol at the very top.

There is the dollar sign at the very end.

There is a square bracket over here and then some of these ranges plus

other characters turns out you don't normally

see these characters and email addresses.

It looks like you're swearing at someone in

their user name but they're valid characters.

They're valid officially.

That doesn't mean that gmail is going to allow you to

put dollar signs and other punctuation in your user name.

But officially some servers might allow that.

So if you really want to validate a user's email address,

you would actually come up with or copy paste something like this.

But honestly this looks so cryptic.

And if you were to type it out manually you are so likely to make a mistake.

What's the better solution here instead?

This is where first past weeks

libraries are your friend?

Surely someone else on the internet,

a program or more experienced than you even has come up with code that validates

email addresses properly using this regular expression

or even something more sophisticated than that.

So generally, if the problem at hand is to validate input,

that is pretty conventional.

An email address, the U r L, something where there's an official definition that's

independent of you.

Yourself find a popular library that you're comfortable using and

use it in your code to validate email addresses.

This is not a wheel necessarily that you yourself should invent.

We've used email addresses though to iterative lee start from something simple.

Too simple and build on top of that.

So,

you could certainly imagine using regular

expressions still to validate things that

aren't email addresses but there are data that are important to you.

So it will at least now have these building blocks.

And it turns out besides these regular expressions and ari dot search,

there are groups.

Ah bad transition. Didn't mean to say that yet.

Sorry.

Give me 1 2nd to get us ready for a few final demos.

Ah

sorry, let me make this smooth. Well, back up in the moment.

Mm hmm.

Just checking some notes.

Okay. Sorry.

All right. Let me do a slightly better transition there

now. It turns out besides ari dot search.

There's other functions in the R E library in python that you might find helpful.

One, for instance, is called ari match,

which is so similar to our research except you don't

have to bother with that first carrot symbol anymore.

Ari dot match will literally for you automatically start searching

for uh match from the start of the string.

Similar in spirit, is ari dot full match,

which is another function in the R E library that also looks

for the start of the string and the end of the string,

thereby Obviating the need for you to have to use

the carrot symbol and the dollar sign as well.

Ultimately, though, you can use our research at least for now.

So long as you use all of that same syntax to express all of these scenarios yourself.

Well,

let's go ahead and transition now to

a completely different demonstration altogether whereby we

maybe start to not just validate the user's input but clean it up.

It's all too common. Uh Sorry, let me fix this.

Mm hmm.

Alright, let me rewind. Sorry, everyone little movie magic.

Just so we can get a better transition here.

Now, besides the regular expressions themselves,

it turns out there's other functions and

pythons are the library for regular expressions.

Among them is this function here ari dot match,

which is actually very similar to ari dot search

except you don't have to specify the Caret symbol

at the very beginning of your rejects if you want to match from the start of a string,

ari dot match by design will automatically start matching

from the start of the string for you.

Similar in spirit is ari dot full match which does the same thing,

but not only matches at the start of the string but the end of the string so

that you two don't need to type in the caret symbol or the dollar sign as well.

But let's go ahead and transition back now to some

actual code whereby we solve a different problem in spirit,

rather than just validate the user's input and make sure it looks the way we want.

Let's just assume that the users are not gonna type in data exactly

as we want and so we're gonna have to clean up their input.

This happens so often when you're using like a Google form

or office 365 form or anything else to collect user input,

no matter what your form question says,

your users are not necessarily going to follow those directions.

They might go ahead and type in something that's a little differently formatted

then you might like.

Now you could certainly go through the results and download a C. S. V.

Or open the google spreadsheet or equivalent and excel

and just clean up all the data manually.

But if you've got lots of submissions, dozens,

hundreds thousands of rows in your data set.

Doing things manually might not be very fun.

It might be much more effective to write code as in python

that can allow you to clean up that data and any future data as well.

So let me propose that we go ahead here and close validate dot pi

And let's go ahead and create a new program altogether called format dot pi.

The goal of which is to reformat the user's input in the format we expect.

I'm gonna go ahead and run code of format dot p.

And let's suppose that the data we're going to reformat is the user's name.

So not email address but name this time.

And we're gonna hope that they type in their name properly like David malin.

But some users might be in the habit

for whatever reason of typing their name backwards.

If you will with a comma such as Mayland.

Comma. David instead.

Now it's fine because both are clearly as readable to the human.

But if you want to standardize how those names are stored in your system,

perhaps a database or C S V.

File or something else, it would be nice to at least standardized or canonical eyes,

the format in which you're storing your data so that if you print out the user's name,

it's always the same format.

David malin and there's no commas or backwardness to it.

So let's go ahead and do something familiar.

Let's go ahead and give myself a variable called name

and set it equal to the return value of input,

asking the user as we've done many times.

What's your name? Question mark.

I'm gonna go ahead and proactively at least clean

up some messiness as we keep doing here by

just stripping off any leading or trailing whitespace just

in case the user accidentally hits the space bar.

We don't want that ultimately

and our data set.

And now let me go ahead and do this as we've done before.

Let me just go ahead quickly and print out just to make sure I'm off to the right start.

Hello and then in curly braces name.

So making an f string to format Hello, Common name.

Now let me go ahead and clear my screen and run python a format dot pi

let me behave and type in my name as I normally would. David space malin enter

and I think the output looks pretty good, it looks as expected grammatically.

Let me now go ahead though and play this game again.

But this time maybe because I'm not thinking or

I'm just in the habit of doing last name,

comma, first I do Mayland comma, David and hit enter.

Alright,

well this now is is weird even though the program is just spitting out exactly what I

typed in arguably this is not close to correct

at least grammatically it should really say hello,

David malin.

Now maybe I could have some if conditions and I could just reject the

user's input if they type a comma or get their names backwards somehow.

But that's gonna be too little too late if the user has already

submitted a form online and I already have the data and now I

need to go in and clean it up and it's not gonna be

fun to go through manually in google spreadsheets or apple numbers or Microsoft,

Excel and manually fix a lot of people's names to get rid of the commas

and move the first name before the last as is conventional in the US.

So let's do this.

It could be a little fragile but let's let's let's

start to express ourselves a little programmatically here and ask this

if there is a comma in the person's name

which is python IQ I'm just asking the question

is this shorter string in this longer string.

Then let me go ahead and do this. Let me go ahead and grab that name in the variable.

Split on not just the comma but the space after

assuming the human typed into space after their name.

And let me go ahead and store the result of that splitting of Mayland comma.

David into two variables.

Let's do last comma first again, unpacking the sequence of values that comes back.

Now let me go ahead and reformat the name.

So I'm going to forcibly change the user's name to be as I expect.

So name is actually gonna be this format string first name, then last name.

Both in curly braces but formatted together with a single space so

that I'm overriding the user's input and updating my name variable accordingly.

For the moment to be clear. This program is interactive.

Like the users like me are typing their name into the program

but imagine the data already is in a C S V file.

It came in from some process like a google form or something else online.

You could imagine writing code similar to this but that

maybe goes and reads that file into memory first.

Maybe it's a C S V via CSP reader or a dict reader

and then iterating over each of those names but we'll keep

it simple and just do one name at a time.

But now what's kind of interesting here is if I go back to my terminal

window and clear it and run python a format dot pi and hit enter.

I'm gonna type in David space mainland as before and I think

we're still good but I'm also gonna go ahead and do this python

a format dot pi malin comma David with a space in between crossing

my fingers and hit enter and voila that now has been fixed.

Such a simple thing to be sure.

But it is so commonly necessary to clean up users input here.

We see at least one way to do so pretty easily.

Now to be fair, there's some problems here.

In fact,

can someone imagine a scenario in which this

code really doesn't fix the user's input,

what could still go wrong even with this fix in my code.

Any thoughts?

Yeah. Sandra,

um the user can still start with the name than Asana and then um

yeah.

So if they type in their their name and then their surname.

Yeah. Yeah. I think we're okay there though, right?

Because I was able to still type in David Space mailer. Yeah.

If they type in their name, comma and then sign them.

Oh, and then something else. Yeah. So let me, let me try this for instance.

Um let me go ahead and run a program and I am the only David Mayland that I know,

but suppose I were uh let's say junior like this and it's

common in english at least to sometimes put a comma there,

you don't necessarily need the comma, but I'm one of those people who uses a comma

that's now really, really broken. So I've broken some assumption there

and so that could certainly go wrong here. What else?

Well, let me go ahead and run this again.

And if I did Mayland comma, David no space because I'm being a little sloppy.

I'm not paying attention,

which is going to happen when you have lots of users ultimately.

Well this really broke. Now notice I have a value error in actual exception. Why?

Well, because split

is supposed to be splitting the string into two

strings by looking for the comma and a space,

but if there is no common space, it can't split it into two things.

And the fact that I have two variables on the left,

but I'm only getting back one thing on the right

means that I can't do this code quite as this.

So it's fragile to be sure. But wouldn't it be nice if we could at least improve it?

For instance, we now know some regular expression syntax.

What if I at least wanted to make this space optional?

Well, I could use my newfound regular expression syntax and put a question mark,

question mark means zero or one of the things to the left.

What's the thing to the left? It's literally a space.

I don't even need parentheses if there's just one thing there.

So that would be the start of a pattern that says I must have a comma

and then I may or may not have a space zero or one spaces thereafter.

Unfortunately,

the version of split that's built into the stir

variable as in this case doesn't support regular expressions.

If we want our regular expressions, we need to go use that library here.

So let me go ahead and do this.

Let me go in and leave this code as is but go up to

the top now and import ari to import the library for regular expressions.

And now let me go ahead and start changing my approach here.

I'm gonna go ahead and do this.

I'm gonna use a new function called ari sorry,

I'm going to use the same function called ari dot search.

And I'm gonna search for a pattern that I think will be last comma first.

So let me use my newfound regular expression syntax and

represent a pattern for something like malin comma space David,

how can I do this?

Well inside of my quotes for ari dot search, I'm going to have something so dot plus,

sorry, I'm gonna have something so dot plus.

Then I'm gonna have a comma.

Then I'm going to have a space then I'm gonna have something

dot plus now I'm gonna preemptively refine this a little bit.

I want this whole pattern to start matching at the beginning of the user's input.

So I'm gonna add the carrot right away and I want

the end of the user's input to be matched as well.

So that I am literally expecting any character one or more times than

a comma and a space than any other character one or more times.

And then that is it.

And I'm going to pass in the name variable as before.

Now when we've used our re dot search in the past,

we really used it just to answer a question does the user's

input match the following pattern or not true or false effectively.

But ari dot search is actually more powerful than that.

You can actually get back more information and you can do this,

you can specify a variable and then an assignment operator and get

back more precise answers to what has been found when searched for,

but what is it you want to get back?

Well,

it turns out there's this other feature of

regular expressions which allow you to use parentheses,

not just to group things together,

but to capture them.

It turns out when you specify parentheses in a regular expression,

unbeknownst to us up until now,

everything in the parentheses will be returned to you

as a return value from the ari dot search function.

It's going to allow you to extract specific

amounts of information from the user's own input.

You can reverse this process to by using the non capturing version as well.

You can use parentheses and then literally a question

mark and a colon and then some other stuff.

And that will say don't bother capturing this, I just want to group things.

But for now we're gonna use just the parentheses themselves.

So how am I going to do this? Well, if I want to get back the users last name

and first name, I think what I want to capture

is the dot plus here

and the dot plus here.

So I've deliberately surrounded in parentheses the dot plus,

both to the left and the right of the

comma not because I'm grouping them together per se,

I'm not adding a question mark, I'm not adding up another plus or star.

I'm using parentheses now for capturing purposes. Why? Well I'm gonna do this next.

I'm gonna still ask a bullying question like if there are matches then do this.

So it matches is not effectively false. Like none.

I do expect I've gotten back some matches and watch what I can do

now I can do last comma first equals whatever matches in and get back all

of the groups of matches then go ahead and update name just like before with

the format string and do first and then last in curly braces as well.

And then at the very bottom just like before print out for instance. Hello

comma name.

So the new code now

is everything highlighted here.

I'm using our research

to search for whether the user type their name in last comma first format

but I am more powerfully using our re dot search to capture some of the user's input.

What's going to get captured?

Anything I surrounded in parentheses will be returned to me as return values.

How do you get at those return values?

You ask the variable to which you assigned them for all of the groups,

all of the groups of parentheses that were captured.

So let me go ahead and do this.

Let me go ahead now and run python of format dot pi enter and I'm

gonna type my name as usual in this case nothing happens with this if condition.

Why? Because I did not type a comma. And so this search does not find a comma.

So there are no matches. So we immediately just print out Hello?

Name, nothing interesting or new there.

But if I now go ahead and clear my screen and run python a format dot pi.

And do Mayland comma space David enter, we've reformatted my name.

Well, how did this work? Let me be a little more explicit now.

It turns out I don't have to just say matches dot groups.

I can get specific groups back that I want. So let me change my code a little bit more.

Let me go ahead now

and just say this, let's update name. Uh Actually let's do this.

Let's say that the last name is going to

be in the matches but specifically Group won the

first name is going to be in the matches but specifically group to why one and two.

Because this is the first set of parentheses to the left of the comma.

This is the second set of parentheses to the right of the comma.

And based on the input,

this would be the users last name in this

scenario malin this would be the user's first name,

David in this scenario.

That's why I'm using Group One for the last name and Group Two for the first

name and now I'm gonna go ahead and say name equals uh f string again.

Uh First and then last

done. And let me

we'll find this one last step before we take questions.

I don't really need these variables if I'm immediately using them,

let's just go ahead and tighten this up further as we've done in the past.

For design sake, if I want to make the name,

the concatenation of the person's first name and last name, let's just do this.

Matches dot group to first plus

a space plus matches dot group one. So it's just up to me to know from left to right.

This is group one, this is group two, so group one is last, Group two is first.

So if I want to flip them around and update the value of name,

I can explicitly get group to first concatenate

using plus a single space and then concatenate on

group one.

Alright, that was a lot. Let me pause to see if there are questions.

The key difference here is we're still using our re dot search

the exact same way but now I'm using its return value.

Not just to answer a question, true or false,

but to actually get back specific matches anything I captured so to speak

with parentheses.

Let's see. Eric if I'm saying that right.

Hi, just a very simple question,

why is it here we're using one and two instead of zero and one

really good question, capturing the first.

A good observation in almost every other context.

We've started counting at zero and one instead of one and two.

It turns out there's something else in location. Zero.

When it comes back from ari dot search related to the string itself.

So according to the documentation of this function,

only one is the first set of parentheses and

to is the second set and onward from there.

Just a different convention here.

Other questions Maria.

Hello dad. Uh what if we write nothing like whitespace? Common white space.

Uh, how we check the truth of condition and second question If we type mixed lettuce,

not work,

What what

if it's still being worked?

And I think I'm not quite sure I heard your audio correctly carter, were you able to

do you mind saying it again, Maria? Your audio was a little off for me.

Uh sorry. Uh if we type whitespace, not worth, not, not name.

And the second question, if we type,

that's not really really worth it, can it will be work for.

I think I caught the first part about white space and so before I answer directly,

let me just run this and make sure I'm not broken anything further.

Let me run python format dot pi. Let me type in David space mail in the right way.

Let me run it once more. Let me type it. Mayland comma.

David the wrong way that we're fixing.

And we're still good, but I think it will still break.

Let me run it a third time with Mayland. Comma. David with no space

and now

it's still broken. Why? Because I'm still looking for comma space.

now, how can I fix that?

One way I could do that is to add a question mark here,

which again is zero or more of the thing before.

So if I have a space and then a question mark, literally no need for any parentheses,

then I can literally tolerate both.

Mayland comma space David or Mayland comma David.

So let's try again before this did not work.

Let's do Mayland comma David with no space now

it does actually work. So we can tolerate different amounts of White space.

If I am a little more precise with my formula, let me go ahead and try once more.

Let me very weirdly but possibly hit the space bar a few too many times.

So now they're really separated.

This again is uh not going to work quite right

because it's gonna consume all of that white space.

So now I might want to strip left and right any of the leading

white space on the result or what I could do here is say this

instead of zero or one. I could use a star here. So space star.

And now if I run this once more with Mayland comma

Space Space Space David enter now we've cleaned up things further.

So you can imagine depending on how messy the data is that you're

cleaning up your regular expressions might need

to get more and more sophisticated.

It really depends on just how many problems

we want to solve it once.

And if I didn't Maria catch all of your questions,

feel free to type in the chat and carter will help proxy or answer as well.

Other questions now on this technique

of capturing in parentheses martin.

Oh you already answered my question. It was about the white space. Okay, excellent.

Well allow me to propose that we forge ahead further just to clean this up even more.

So using a feature that's actually relatively new to python itself,

it is very common when using regular expressions to do exactly what I've

done here to call a function like ari dot search with capturing parentheses inside

such that you get back a return value that I'm calling matches.

You could call it something else but I'm calling it by default

matches and then notice on the next line I'm saying if matches,

wouldn't it be nice if I could just tighten things

up further and do these all on the same line.

Well you can sort of

let me go ahead and do this. Let me get rid of this.

If and let me just try to say something like

this if matches equals our research and then colon.

So combining

my if condition

into just one line instead of those two

in C or C. Plus plus or java.

You would actually do something like this

surrounding the whole thing with parentheses.

Sometimes double sets to suppress any warnings if you want to do two things at once,

if you want to not only assign

the return value of ari dot search to a variable called matches,

but you want to subsequently ask a bullying question,

is this effectively true or false?

That's what I was doing a moment ago. Let me undo this a moment ago.

I was getting back the return value and assigning it to matches.

And then I was asking the question,

Well, it turns out this need to have two lines of code

presumably rubbed people wrong for too long in python.

And so you can now combine these two kinds of lines into one.

But you need a new operator.

You cannot just say if matches equals our research and then into Copeland at the end,

you instead need to do this,

you need to do colon equals if and only if you want to assign something from right to

left and you want to ask an if or an L if question on the same line.

This is affectionately known as You can see here as the

walrus operator and it's new to python in recent years.

And it both allows you to assign a value as I'm doing from right to left

and ask a bullion question about it.

Like I'm doing with the if or equivalently Elliff

does anyone know why this is called the walrus operator.

If you kind of look at it like this.

Perhaps if you're familiar with walruses, it kind of sort of looks like a walrus.

So a minor detail but a relatively

new feature of python that honestly you'll probably

continue to see online and in source code and in textbooks and so forth,

increasingly so now that it does exist, it does not change the logic at all.

If I run python format dot pi and type malin,

comma space, David,

it's still fixes things but it's tightened up my code just a bit more.

Alright, how about some final examples here where we go about?

Sorry, let me just organize my thoughts

before we spoil

and

one moment, apologies.

Okay, let me rewind.

Mhm.

Alright,

let's go ahead and look at one final problem

to solve that of extracting information now as well.

So at this point we've now validated the user's input

by checking whether or not it meets a certain pattern,

We've cleaned up the user's input by checking against the pattern

whether it matches or not and if it does match,

we kind of reorganize some of the user's information so we can clean up

their input and standardize the format in which we're storing or printing it.

In this case,

let's do one final example where we're very specifically

extracting information in order to answer some question.

So let me propose this.

Let me go ahead and close format dot pi and create a new file called twitter dot pi,

the goal of which is to prompt users for the U. R. L.

Of their twitter profile and extract from it. Infer from that U. R. L.

What is the user's user name now? Why might you want to do this?

Well one you might want users to be able to just very easily copy and paste the U. R. L.

From their own twitter profile into your form into your app

so that you can figure out what their user name is.

Or you might have a form that asks the user for their twitter user name.

And because people aren't necessarily paying very close attention,

some people type their user name, some people type their whole U.

R. L. Or something else altogether.

It would be nice now that you're a programmer to just be more tolerant

of different types of input and just take on the burden of canonical izing,

standardizing the data.

But being flexible with the users it's arguably a better user experience.

If you just let me copy, paste or type in what I want, you clean it up,

you're the programmer, not me lens for a better experience perhaps.

Well let me go ahead and do this with twitter dot pi.

Let me first go ahead and prompt the user here for value for a variable that I'll call.

You are L and just ask them to input the U. R. L. Of their twitter profile.

I'm gonna go ahead and strip off any leading or trailing

whitespace just in case users accidentally hit the space bar.

That's like literally the least I can do quite easily.

But now let's go ahead and do this

suppose that the user's address is the following.

Let me print out what they type in and let me

clear my screen and run python of twitter dot pi.

I'm gonna go ahead and type in for instance https colon slash slash

twitter dot com slash david J. Malan.

Which happens to be my own twitter user name for now.

We're just gonna print it back onto the screen

just to make sure I've not messed up yet.

Okay so I've printed back out the exact same U. R. L.

But the goal at hand is to extract the user name only.

Now let me just ask perhaps a straightforward question

logically. What do I need to do to get at the user's user name? I don't need code.

I don't need answers in python.

Just give me a sense of what I need to do to

get the answer I want when the user types in the U.

R. L. Like that Ivan.

Well uh we just ignore what's before the user

name and then just extract the user name.

Perfect. Yeah I mean it is as simple as that if you know the user names at the end.

Well let's just somehow ignore everything to the beginning.

Well what's at the beginning? Well it's A. U. R. L.

So we're probably gonna need to ignore an https a

colon slash slash twitter dot com and a slash.

So we just want to throw all of that away. Why? Because if it's U. R. L.

We know by how twitter works that the user name comes at the end.

So let's use that very simple idea to get at the information we want.

Well, I'm gonna try this a few different ways.

Let me go back into my program here and instead of just printing it out,

which was just to see what's going on,

Let me do this. Let me create a new variable called user name.

And let me call you RL dot replace.

It turns out that if you are L is a string or a stir in python,

it again comes with multiple methods like strip uh and split and others as well.

One of which is called replace and replace will

do just that you pass the two arguments.

The first of which is what do you want to replace?

The second argument is what do you want to replace it with?

So if I want to get rid of as Ivan proposed

really just everything before the user name that is the twitter,

U R.

L.

Or the beginning there of let's just say this go ahead and

replace https colon slash slash twitter dot com slash close quote.

That's what I want to replace and comma second argument.

What do you want to replace it with?

Nothing.

So I'm literally gonna pass in quote unquote to effectively do a find and replace.

That's what the replace method does.

Just like you can do it in Microsoft word or google docs.

This is the programmer's way of doing find and replace now. Let me go ahead and

print out just the user name.

So I'll use an F string like this, I'll say user name,

colon and then in curly braces user name just to format it nicely.

Alright, let me go ahead and clear my screen and run python of twitter dot pi enter

U R L. Here we go https colon slash slash twitter dot com

slash david. J malan

enter. Ok, now we've made some progress done for the day. Right.

Well what is suboptimal about this? Can anyone critique or find fault with

my program? It is working now but it's a little fragile.

I bet we could contrive some scenarios where I

think it works but it doesn't any thoughts Alex.

Okay, thank you. Well I have a few ideas actually.

Well first of all uh if we don't if you don't specify https it will broken secondly,

if we have slash

but also the broken, if we if we have like a question mark,

it's after after question mark.

It also won't work. So

actually oh my God, I mean here we are.

I was pretending to think I was done but my God,

like Alex give us a whole laundry list of like problems.

And just to recap then what if it's not https,

it's http slightly less secure but I should

still be able to tolerate that programmatically.

What if the protocol is not there?

What if the user just typed twitter dot com slash David. J. Malan?

It would be nice to tolerate that rather than show

an error and make me type in the protocol.

Why? It's not good user experience?

What if it had a slash at the end of the user name or a question mark?

If you think about you.

RLS you've seen on the web, there's very commonly more information,

especially if it's been shared on social media.

There might be http parameters, so to speak. Just stuff there that we don't want.

There could be a W W W dot twitter dot com.

Which I'm also not expecting but does work if you go to that you are L. Two.

So there's just so many things that can go wrong.

And even if I come back to my contrived example of earlier,

what if I run this program and say this is my user name

is https colon slash slash twitter dot com slash David J malin enter.

Well that to just just didn't really work. It got rid of the you actually

okay.

Actually that kind of worked but the goal here

is to actually get the user's user name,

not an english sentence describing the users user name.

So I would argue that even though I

just accidentally created perfectly correct english grammar,

I did not extract the twitter user name correctly.

I don't want words like my user name is as part of my input.

So how can we go about improving this and

maybe chipping away at some of those problems 1x1.

We'll let me clear my screen here.

Let me come back up to my code and let me

not just replace it but let me do something else.

Instead,

I'm gonna go ahead and instead of using replace

I'm gonna use another function called remove prefix.

A prefix is a string or a sub string that comes at the start of another.

So if I remove prefix I don't need a second argument for this function,

I just need one.

What prefix do you want to remove?

So this will at least now fix the problem I just

described of typing in like a whole sentence where the U.

R. L. Is there but it's not the beginning, it's only at the end.

So here this still is not correct but we don't

create this weird looking output that just removes the U.

R. L. Part of the input.

Uh My user name is https colon slash slash twitter

dot com slash David J malan a moment ago.

It did remove the U. R. L. And left only the David J. Malan.

This is not perfect. Still but at least now it does not weirdly removed the U. R. L.

And then leave the english? It's just leaving it alone.

So maybe I could handle this better.

But at least it's removing it from the part of the string I might anticipate.

Well, what else could we do here?

Well,

it turns out that like regular expressions just

let us express patterns much more precisely.

We could spend all day using a whole

bunch of different python functions like remove,

prefix or remove and strip and others and kind of make our way to the right solution.

But a regular expression just allows you

to more succinctly if admittedly more cryptically

express these kinds of patterns and goals.

And we've seen from parentheses which can be used

not just a group symbols together as sets,

but to capture information as well.

We have a very powerful tool now in our toolkit.

So let me do this.

Let me go ahead and start fresh here and import the ari library as before.

At the very top of my program,

I'm still gonna get the users u r l via the same line of code,

but I'm now gonna use another function as well.

It turns out that there's not just ari dot search or rd dot match or ari dot full match.

There's also ari dot sub

in the regular expression library where sub here

means substitute and it takes more arguments,

but they're fairly straightforward.

The first argument to ari dot sub is the pattern

the regular expression that you want to look for,

then you have a replacement string. What do you want to replace that pattern with?

And where do you want to do all that?

Will you pass in the string that you want to do the substitution on Then?

There's some other arguments that I'll wave my hands up for now.

Among them are those same flags.

And also account like how many times do you want to do? Find and replace?

Do you want it to do all? Do you want to do it? Just one or so forth?

You can have further control there too.

Just like you would in google docs or Microsoft word.

Well let me go back to my code here

and let me do this.

I'm gonna go ahead and call ari not search but ari dot sub for substitute.

I'm gonna pass in the following regular expression,

https colon slash slash twitter dot com.

Uh slash And then I'm gonna close my quote. And now what do I want to replace that with?

Well like before with the simple stir replace function.

I want to replace it with nothing. Just get rid of it altogether.

But what string do I want to pass in to do this to the U. R. L. From the user.

And now let me go ahead and assign the return value of R. E. Sub

to a variable called user name. So ari subs purpose in life is again to substitute

some value for some regular expressions some number

of times it essentially is find and replace using

regular expressions and it returns to you the

resulting string once you've done all those substitution.

So now the very last line of my code can be the same as before print.

And I'll use an F string user name, colon. And then in curly braces user name.

So I can print out literally

just that. Alright, let's try this and see what happens.

I'll clear my terminal window run python of twitter dot pi and here we go,

https colon slash slash twitter dot com slash david.

J malan. Cross my fingers and hit enter. Okay,

now we're in business

but it is still a little fragile. And so let me ask the group

what problems should I now further chip away at they've been said before.

But let's be clear what's one or more problems that still remain.

But I think it's gonna be easier to solve them with regular

expressions than with just a whole bunch of separate python functions.

Gene,

uh the protocols and the uh

good the protocol. So http versus https.

Maybe the sub domain www should it be there or not?

And there's a few other mistakes here to let me actually stay with the group.

What are some other shortcomings of this current solution?

Any other problems Hector.

Hi,

if we use a phrase like you do before we are going to have the same

problem because it's not taking account in the

first part of the the the text example.

Good. I might still allow for like some words uh some english to the left of the U. R. L.

Because I didn't use like my carrot symbol so I'll fix that.

And any final observations on shortcomings here.

Think adversary really with my code and soon with yours. What could go wrong?

Uh Hell if I'm saying it right.

Uh Well it could be a http or there could be like less than two slashes and

okay so it could be http and I think that

was mentioned to in terms of protocol there could be

fewer than two slashes that I'm not gonna worry about

if the user gives me one slash instead of two.

That's really user error. And I could be tolerant of it.

But you know what At that point I'm okay yelling at

them with an error message saying please fix your input.

Otherwise we could be here all day long trying to handle all possible typos

for now. I think in the interests of usability or user experience. Ux

let's at least be tolerant of all possible

valid inputs or reasonable inputs if you will.

So let me go here and let me start chipping away at these here.

What are some problems we can solve? Well

let me propose that we first address the issue

of matching from the beginning of the string.

So let me add the carrot to the beginning and let

me add not a dollar sign at the end though.

Right?

Because I don't want to match all the way to the

end because I want to tolerate a user name there.

So I think we just want the carrot symbol there.

There's a subtle bug that no one yet mentioned. And let me just kind of highlight it

and see if it jumps out at you now. It's a little subtle here on my screen.

I've highlighted in blue a final bug here. Maybe some smiles on the screen. Yeah.

Can we take one hand here?

Why am I highlighting the dot in twitter dot

com even though it definitely should be there.

Uh I mean if I'm saying it right.

Yeah.

Yeah so

yeah exactly it's not it means any character.

So I could type in something like twitter question mark,

calm or twitter anything calm and that would actually be tolerated.

It's not really that bad because why would the user do that?

But if I want to be correct and I wanna be able to test my own code properly.

I should really get this detail right?

So that's an easy fix to but it's a common mistake anytime you're writing

regular expressions that happened to involve special symbols like dots in a U.

R. L. Or domain name, a dollar sign and something involving currency.

Remember you might indeed need to escape it with a backslash like this here.

Alright let me ask the group about the protocol specifically

https is a good thing in the world it means secure, there is encryption being used.

So generally you like to see https but you

still see people typing or copy pasting http.

What would be the simplest fix here to tolerate? As has been proposed? Both http

and https.

I'm gonna propose that I could do this,

I could do http vertical bar or https which again means A or B.

But I think I can be smarter than that.

I can keep my code a little more succinct any recommendations here for tolerating

http or https

here. Too many ways to solve martin.

We could try to put in question mark behind the S. Perfect. Just use a question mark.

Right that both of those would be viable solutions.

If you want to be super explicit in your code fine use

parentheses and say http or https so that you the reader,

your boss, your teacher just know exactly what you're doing.

But

you know if you keep taking the more verbose approach all the time,

it might actually become less readable.

Certainly once your regular expressions get this big instead of this big.

So let's save space where we can and I would argue that this is pretty reasonable.

So long as you're in the habit of reading regular

expressions and know that question mark does not mean a literal

question mark but it means zero or one of the things

before I think we've effectively made the s optional here.

Now, what else can I do?

Well suppose we want to tolerate the w W W dot, which may or may not be there.

But it will work If you go to a browser, I could do this www dot.

Uh wait, I want a backslash there so I don't repeat the same mistake as before.

But this is no good either because I want to tolerate www being there

or not being there and now I've just required that it be there.

But I think I can take the same approach. Any recommendations.

How do I make the www dot optional? Just to hammer this home?

How do I make this optional here? Yeah, Maria,

we can like group

square and the question mark. Perfect.

So question mark is the short answer again,

but we have to be a little smarter this time.

As Maria's noted,

we need parentheses now because if I just put a question mark after the dot,

that just means the dot is optional.

And that's wrong because we don't want the user to type in www T W I T T E R.

We want the dot to be there or just not at all with no www.

So we need to group this whole thing together,

put a parenthesis there and then a parenthesis, not after the third W after the dot.

So that that whole thing is either there or it's not there.

And what else could we still do here?

You know,

there's gonna be one other thing we should tolerate and

it's been said before and I'll pluck this one off.

What about the protocol?

Like what if the user just doesn't type or doesn't copy paste

the http colon slash slash or an https colon slash slash?

Right.

Honestly you and I are not in the

habit generally of even typing the protocol anymore.

Nowadays you just let the browser figure it out

for you and automatically add it is instead.

So this one's gonna look like more of a mouthful.

But if I want this whole thing here in blue

to be optional, it's actually the same solution as Maria offered a moment ago.

I'm gonna go ahead and put a parenthesis over

here and a parenthesis after the two slashes and then

a question mark. So as to make that whole thing optional as well.

And this is okay, It's totally fine to make this whole thing optional or inside of it.

This little thing. Just the s optional as well.

So long as I'm applying the same principles again and again,

either on a small scale or a bigger scale,

it's totally fine to nest one of these inside of the other

questions. Now on any of these refinements

to this parsing this, analyzing of twitter?

Yeah. Over two.

Uh huh

raj modern if I'm saying it? Right,

yes, we can

what if we put a vertical bar

besides this www dot

what if we use a vertical bar there.

So we could do something like that to we could do something like this.

Uh instead of the question mark,

I could do www dot or nothing and just leave that in the parentheses.

That too would be fine.

I personally tend not to like that because it's a little less obvious to me.

Wait a minute.

Is that deliberate or did I forget to finish

my fault by putting something after the vertical bar?

But that too would be allowed there as well if that's what you mean.

Other questions on where we left things here

where we made the protocol optional to Solomon.

Uh what would have happened if we have parenthesis,

parenthesis and then inside we have another parenthesis and another parenthesis.

We're going to deal with each other.

If you have parentheses inside of parentheses, that too is totally fine.

And indeed that should be one of the

reassuring lessons today.

As complicated as each of these regular expressions has admittedly gotten.

I'm just applying the exact same principles in

the exact same syntax again and again.

So it's totally fine to have parentheses

inside of parentheses if they're each solving different

problems and in fact the lesson I would really emphasize the most today is that

you will not be happy if you try to write

out a whole complicated regular expression all at once.

Like if you're anything like me,

you will fail and you will have trouble finding the mistake because my God,

look at these things, they are, even to me all these years later, cryptic.

The better way I would argue whether you're new to programming or as old to it as I am,

is to just take these baby steps,

these incremental steps where you do something simple, you make sure it works,

you add one more feature, make sure it works, add one more feature,

make sure it works.

And hopefully by the end because you've done each of those steps one at a time,

the whole thing will make sense to you,

but you'll also have gotten each of those steps correct um at each turn.

So please do avoid the inclination to try to come up with long sophisticated regular

expressions all at once because it's just not a good use of the time.

If you then stare at it,

trying to find a mistake that you could have

caught if you did things more incrementally instead.

Well,

let me make some final improvements to this

example here whereby I'm gonna go ahead and make

sure that I'm only printing out the users user name if in fact I detected it,

recall that ari sub and our research.

Um

Sorry, let me figure this out.

Sorry, let me rewind and say this again.

Ah

um Sorry, just thinking for a moment,

give me just one second, make sure we get this final detail right,

okay.

Alright.

There still remains arguably at least one problem with this solution in

that even though I'm calling ari dot sub to substitute the U.

R. L. With nothing quote unquote.

I then on my final line of code line six and just blindly assuming that

it all worked and I'm going to go ahead and print out the user name.

But what if the user if I clear my screen here and run python of twitter dot pi?

He doesn't even type a twitter U. R. L.

What if they do something like https colon slash slash www dot

google dot com slash like completely unrelated li for whatever reason enter

that is not their twitter user name.

So we need to have some conditional logic I would argue.

So that for this program sake we're only printing out or in the

back end system we're only saving into our database or a C.

S. V. File the user name if we actually matched the proper pattern.

So rather than use ari dot sub which is useful for cleaning up data

as we've done here to get rid of something we don't want there.

Why don't we go back to ari dot search where we began today

and use it to solve the same problem.

But in a way that's conditional whereby I can confidently say yes

or no at the end of my program here's the user name

or here it is not. So let me go ahead now and I'll clear my terminal window here.

I'm gonna keep most of the time.

I'm gonna keep the first two lines the same where I import ari and I get the U. R. L.

From the user. But this time let's do this.

Let's this time search for using ari dot search instead of ari dot sub the following.

I'm going to start matching at the beginning of the ur of the string

https question mark. To make the s optional colon slash slash.

Then I'm gonna make my uh W. W. W. Optional by putting that in question marks there.

Then at twitter dot com with a literal dot there.

So I'll stay ahead of that issue to then A slash.

And then. Well this is where David J. Malin is supposed to go. How do I detect this?

Well I think I'll just tolerate anything at the end of the U. R. L. Here.

Alright, dollar sign at the very end. Close quote for the moment.

I'm gonna stipulate that we're not gonna worry about question

marks at the end or hashes like for fragment I.

D. S. And U. R. L. S. We're going to assume for simplicity now that the U. R. L.

Just ends with the user name alone.

Now what am I going to do? Well I wanna search for this U. R. L.

Specifically and I'm going to ignore case. So ari dot ignore case.

Uh applying that same lesson learned from before.

Ari dot search recall will return to you the matches you've captured.

Well, what do I want to capture?

Well, I want to capture everything to the rights of the twitter dot com. U R L. Here.

So let me surround what should be

the users user name with parentheses.

Not for making them optional, but to say capture this set of characters now.

Ari dot search, recall returns and answer. Matches will be my variable name again.

But I could call it anything I want

and then I can do this if matches. Now. I know I can do this.

Let's print out the formats during user name colon.

And then uh what do I want to print out?

Well, I think I want to print out matches dot group one for my matched user name.

All right. So what am I doing? Just to recap?

Line one, I'm importing the library line two. I'm getting the U R. L.

From the users so nothing new there. Line five. I'm searching the user's U R L.

As indicated here is the second argument for this regular expression.

This pattern I have surrounded the dot plus

with parentheses so that they are captured ultimately,

so I can extract in this final scenario the users user name.

If I indeed got a match and matches is non none.

It is actually containing some match then and only

then print out user name in this way.

Let me try this now.

If I run python of twitter dot pi and type in https colon

slash slash www dot google dot com slash Now nothing gets printed.

So I've at least solved the mistake.

We just saw where I was just assuming that my code worked.

Now I'm making sure that I have searched for and found the twitter U. R. L prefix.

Alright well let's run this for real now,

python of twitter dot pi https colon slash slash

twitter dot com slash David J. Malan. But note I could use http I could use W W W.

I'm just going to go ahead here and hit enter.

Huh?

None.

What has gone wrong?

This one's a bit more subtle

but why does matches dot group one contain nothing. Wait a minute.

Let me maybe I maybe I did this wrong. Maybe. Maybe. Do we need the W. W. W.

Let me run it again.

So here we go https colon slash slash let's add at www dot twitter dot com slash David.

J. Malan. Alright, enter.

Whoa.

What is going on?

Abdullah.

Abdullah? Sorry.

Abdullah.

If I'm saying it right?

Yes. Now we can hear you.

Uh we have two

groups.

I didn't hear that. You want to say again?

We have to save group to I have to say group to.

Well, wait all right,

because we had the sub domain was optional and to make it optional,

I needed to use parentheses here.

And so I then said zero or one.

Okay, so that means that actually I'm unintentionally.

But by design capturing the www dot or none of it if it wasn't there before.

But I have a second match over here because I have a second set of parentheses.

So I think, yep, let me change matches group won two matches,

group two and let you run this python of twitter

dot pi https colon slash slash www dot twitter.

Let's do this uh twitter dot com slash David J malan

enter. And now we've got access to the user name.

Let me go ahead and tighten it up a little bit further. If you like our new friend.

It's hard not to like if we like our old friend, the walrus operator.

Let's go ahead and add this just to tighten things up.

Let me go back to bs code here and let me get rid of

the unnecessary condition there and combine it up here if matches equals that.

But let's change this single assignment operator to the walrus operator.

Now I've tightened things up further.

But I bet I bet I bet there might be another solution here.

And indeed it turns out that we can come back to this final set of syntax,

recall that when we introduced these parentheses, we did it so that we could do A or B.

For instance with the vertical bar.

That you can even combine more than just one bar,

we used the group to combine ideas like the www dot

and then there's this admittedly weird syntax at the bottom here.

Up until now, not used.

There is a non capturing version of parentheses.

If you want to use parentheses logically because you need to

but you don't want to bother capturing the result.

And this would arguably be a better solution here because yes, if I go back to V.

S code, I do need to surround the www.

Dot with parentheses at least as I've written my rejects here

because I wanted to put the question mark after it.

But I don't need the www dot coming back.

In fact,

let's only extract the data we care about just so there's no

confusion down the road for me or my colleagues or my teachers.

So what could I do?

Well, the syntax for this slide is to use a question mark and a colon

immediately after the open parenthesis. It looks weird, admittedly,

those of you who have prior programming experience might recognize

the syntax from turnberry operators doing an if else,

all in one line,

a question mark, colon at the beginning of that parenthetical means

yes, I'm using parentheses to group these things together, but no,

you do not need to capture them instead so I can change my code back now.

Two matches dot group one. I'll clear my screen here.

Run python of twitter dot pi I'll again run here

https colon slash slash twitter dot com slash David,

j malan with or without the www.

And now I indeed get back that user name.

Any questions then

on this final

techniques?

Any questions now? Yeah. Over to

your go.

Hi, hi, thanks David. Um I have two questions if that's okay.

So first,

well can we move the caret right at the beginning of twitter and then

just start reading from there and then get rid of everything else before that,

the kind of w w uh issues that we had.

And then my second question is how would we um use kind of,

I guess it's either a list or a dictionary to to sort the

dot com kind of thing because we have dot co dot UK.

And that kind of start, how would we bring that into uh the ari function?

A good question. And let me clarify your first question.

What what did you ask about the carrot exactly?

So could we move the caret just before twitter dot com so

that we don't have to deal with the https and www.

A good question.

But no,

if I move the carrot before twitter dot com and throw away the protocol and the www.

Then the user is gonna have to type in literally twitter dot com slash user name.

They can't even type in that other stuff. So that would be a regression to step back

as for the dot com and the dot org and dot e d u and so forth.

The short answer is there's many different solutions here.

If I wanted to be stringent about dot com.

And suppose that twitter probably owns multiple domain names

even though they tend to use just this one.

Suppose they have something like dot org as well.

You could use more parentheses here and do something like this. Com or org.

I probably want to go in and add a question mark colon

to make it non capturing because I don't care which it is.

I just want to tolerate both. Alternatively we could capture that.

We could do something like this where we do dot plus.

So as to actually capture that and then we could do something like this.

If matches dot group

one now equals equals calm, then we could support this.

So you could imagine factoring out the logic just by

extracting the top level domain or T L D.

And then just using python code, maybe a list,

maybe a dictionary to validate elsewhere outside of the rejects.

If it's in fact what you expect for now though. We kept things simple.

We focused only on the dot com in this case.

Other questions on these reflexes.

Actually over to you?

My question is from a while back,

you showed the cryptic code right from carried to the dollar.

So why can't we use slash w instead of writing from me

to see to the numbers and just grouping the other special characters.

So I showed multiple approaches for the user name and the

domain name back when we were focusing on email addresses and

I did it just to show the equivalents backslash W is

the same thing as the square brackets with little a few

little Z big A through big Z zero through nine.

And an underscore I went to backslash W because it's way faster to type and it's just a

little more semantically clear like backslash W sounds like

word and so it just reminds me that okay,

it's a word character.

However,

recall that that wasn't good enough because some of you had periods in your user

name and a period for better or for worse is not part of backslash W.

So I could go back and use the square brackets and add a period a backslash period

to that list of characters or I could do backslash W or vertical bar backslash dot.

This is again,

just to say there's many different ways

to solve these problems and at least initially

I would go with whichever one is most comfortable to you and most readable for you

And others avoid

writing a regular expression like the crazy browser one which has to be used

by someone but generally probably doesn't need to be in our own code.

How about one other question on reg exes here?

Yeah. Priscilla.

Okay. Back before. Uh one guy said about the group one and group

two.

There is a mistake or invalid things

that doesn't come the usual name

and I'm

I'm stick there.

Do you remember

something that you put and

Back before the

Group one and Group two.

Can I can I see this again because that that became

invalid in the name you can get the user name.

Yes.

So I think I'm not sure if I'm hearing this right,

But before I added the question mark,

colon syntax which came from this this summary here.

I was accidentally capturing the www dot in part of my

then you put the twitter poll on

dot com

and that's not appears they use their name. Oh but notice what I did.

So let me go back to that if that's what you mean.

So if I change the dot com to uh com or org like I did before I No no no no no.

Really. Really?

Before I don't want to know what I need to

do you want to try asking in the chat more specifically and

maybe carter can look through the previous examples if that's okay.

Of course. Sorry for not following. Well let me let me rewind for just a moment here.

Okay,

let me go ahead and clear my terminal and

make one final refinement on this twitter example.

It turns out that we're being a little sloppy here. Even at the end whereby dot

is indeed too accommodating of old characters.

Indeed it means any character there. Even if it's not allowed.

So if the user did copy, paste the U. R. L.

That has a question mark or a hash symbol or just really some odd punctuation.

It might get included accidentally in our parsing

that is extraction of the user name and therefore

our answer is still going to be invalid.

So I actually went into the documentation for twitter dot com and as of today,

the only symbols that twitter officially supports in user names

are

A through Z, zero through nine

and underscore our old friend if you will.

So it turns out a better approach here would be

especially if we know something about the domain twitter specifically.

Let's go ahead and be more explicit.

So inside of my parentheses let's additionally use our old

square brackets and specify that a through Z is allowed

or zero through nine is allowed or an underscore.

And that's it.

According to twitter's own documentation,

I should not be as generous as any character.

I should only allow these characters.

I didn't need to specify capital A through capital Z because why I'm using

ari dot ignore case so I can handle upper case or lower case insensitively.

So that's fine. So now let me go ahead and one final time run python of twitter dot com.

Run https colon slash slash twitter dot com slash something like David J malan.

Um And I'll even put a trailing slash at the end here,

enter

that did not catch it

so close here,

how can I tolerate those stuff after the user name,

Like a slash like was noted or a question mark or a hash

or something else. I'm so close now

to tolerating the U. The user name and some other stuff at the end. Yeah.

Your thoughts,

Nikita

and uh

you know.

Yes.

So I think uh

still there.

Oh we lost your audio I think.

Let me afraid we can't hear you here. So let me rewind. So let me recap what I did.

Let me go ahead and run python of twitter dot pi typing

in https colon slash slash twitter dot com slash David J.

Malan. But let me put in a

trailing slash as might be the case

enter

and now it's ignoring me all together. So now

that we know what characters characters to expect for the user name,

I think we can maybe even get rid of this dollar sign.

Why the dollar sign is saying we have to match

everything up until the end of the user's input.

But you know what?

Now I'm okay with there being something a little more at the end of the U R L.

Maybe a slash, maybe a question mark, maybe a hash symbol,

all of which are valid symbols in a U R L.

But are not part of the users user name

but anything that is a letter of the alphabet

or a decimal digit or an underscore

will I know by definition of twitter's documentation

be part of the user name. So now if I run this one more time,

python of twitter dot pi enter https colon slash slash twitter dot com slash david J.

Malan with or without this slash. Now I indeed

um

ah I messed it up. Okay, what did I do?

Apologies. That was gonna be our final flourish here.

I'm sorry, I see what I did wrong. Um

let me rewind if that's okay just so that we get this right. Um

so here we were, even though you know where this is going now,

now let me go ahead and make one final change to this

twitter example because I know a little something about these user names

and I think I'm being a little too generous now by just

saying dot plus at the end of the U R L.

Because again dot means any character.

But according to twitter's own documentation, twitter, Urs can

only contain letters of the alphabet, A through Z,

Decimal digits, zero through 9 or

underscores. And we've seen that pattern before,

which is to say that if there's other characters at the end of the U R L.

Probably they can be there but they're not part of the user name.

Maybe there's a slash, maybe there's a question mark,

maybe there's a fragment symbol, hash all of which are valid symbols in the U.

R. L.

But are not going to be part of the user name. So how can I go about tolerating that?

Well at the end of the U. R. L. Let me use our square brackets again and say a through Z.

zero through nine as well as an _

I still want to capture the user name. So let me surround it with parentheses again.

But let me also add a plus so that it is still one or more of those characters.

So I at least have a user name there.

Let me go ahead now and I'm ignoring case

so I don't need to bother with uppercase specifically.

It will be a case insensitive search.

And now let's run python of twitter dot pi typing in the U. R. L.

Like https colon slash slash twitter dot com slash david J. Malan.

With or without a slash or other symbols. I'm gonna go ahead and enter now and my user.

Ah

thank you. I'm sorry. I feel like now I'm just wasting everyone's time.

My apologies. I screwed up.

That's fine. We'll hit that

if everyone doesn't mind. Let me do this one last time so that we can all be happy.

I apologize.

Alright, here we go.

All right.

Let me do one final version of this twitter program that allows us

to be a little more exact when it comes to these user names.

So first let's make sure that we

oh

let's do this.

Let's start that way because that part that change came from a question.

So let's leave it like this.

Alright,

let's make one final change so that we're being a little more

consistent with the official definition of a twitter user name right now.

I'm being a little

dammit. Sorry, this is where it was.

Sorry everyone.

Alright,

let's make one final change to this program so that we're being

a little more specific with the definition of a twitter user name.

It turns out that we're being a little too

generous over here whereby we're accepting one or more of

any character. I checked the documentation for twitter

and twitter only supports letters of the alphabet, A through Z

Numbers zero through 9 or _. So not just dot, which is literally anything.

So let me go ahead and be more precise here at the end of my string.

Let me go ahead and say

this set of symbols in square brackets.

I'm gonna go ahead and say A through Z

zero through nine and an underscore because again,

those are the only valid symbols I don't need to

bother with an uppercase A or lower case C.

Because we're using ari dot, ignore case over here.

But I want to make sure now that I tolerate not only one or more of

these symbols here but also maybe some other stuff at the end of the U.

R. L.

I'm now going to be okay with there being a slash or

a question mark or a hash at the end of the U.

R. L. All of which are valid symbols in the U. R. L.

But I know from the twitters documentation are not part of the user name.

Alright now I'm gonna go ahead and run python of twitter dot pi one

final time typing in https colon slash slash twitter dot com slash David.

J. Malan. Maybe with maybe without a trailing slash.

But hopefully with my biggest fingers crossed here,

I'm gonna go ahead now and hit enter

and thankfully my user name is indeed

David J. Malan.

So what more is there in the world of regular expressions and this own library,

not just

ari dot search and also ari dot sub. There's other functions too.

There's ari dot split via which you can split a

string not using a specific character or characters like a comma

and a space but multiple characters as well.

And there's even functions like ari dot find all,

which can allow you to search for multiple copies of the same pattern in different

places in the strength so that you can perhaps and manipulate more than just one.

So at the end of the day,

now you've really learned a whole other language like that

of regular expressions and we've used them in python,

but these regular expressions actually exist

in so many languages too among them,

javascript and java and ruby and more so with this new language even

though it's admittedly cryptic when you use it for the first time.

You have this newfound ability to express these patterns

that again you can use to validate data to clean up data or

even extract data and from any dataset you might have in mind.

That's it for this week. We will see you next time

then we'll do the pickup,

we're all set, can we do Q. And A. And then the pickup

max. Am I still alive

max?

Okay, alright, so thank you so much for joining us today.

We do have a few minutes for a couple of questions.

If you would like trey, can we go over to you first?

Mhm.

Uh And the very last thing you said you

said something about separating um separating and stuff,

would you be able to use that with your CSP, the thing you did last week?

Would you be able to use your regular expressions with that as well?

Yeah, we could have a really good connection.

So last week for those unfamiliar we did file io we focused on CS.

V files comma separated values which allowed us to store

data in text files using commas to separate them.

Trade we could use regular expressions to parse those files

But honestly it gets painful quickly anytime some of

the data is quoted like # four Privet Dr.

Now your regular expression somehow has to look for or not

look for quotation marks to and therefore treat the commas separately.

So it's totally doable

but it ends up becoming pretty complex and so

that's why we would still recommend using the C.

S. V. Module because someone else has dealt with all of those headaches

other questions.

Yeah Michael.

Um Yeah so um first of all I want to say thank you to you for doing these classes.

It's really awesome to be able to um learn this way um

remotely and so many people at once.

Um The question I had was related to the problem sets.

Um Should we when we're going through the problems that should we limit um

what we used to solve them to what was what's been covered so far in the course.

It's a good question. Um Unless we specify we don't necessarily check that

whether you are or not. Using more advanced techniques

insofar as each problem set in each week

is really meant to reinforce certain lessons.

I would probably encourage you to limit yourself to the ideas from that week.

If only so that you're really hammering in that week's ideas.

Um But we're not gonna you won't lose credit.

For instance if you're using regular expressions in week two

when really we didn't introduce them until week seven.

Okay. Yeah that's kind of what I was thinking other questions. Time for a few more.

Yeah official

not a question but I just wanted to thank you that you are teaching us.

You're taking your time out of your schedule and your teaching us.

So I'm just really grateful that you're teaching us because I don't think that

honestly I would have been able to study at such a prestigious college ever.

I

am just really grateful

and if ever I can do anything um

okay for you I am

uh

but if there is anything that you can you want, just let me

thank you.

If you want you can have my email is

never really ever visited

in India and you should definitely visit with that. But it is a,

it is also called the city of lakes.

So if you ever get the chance to visit

that, that is in India you should, I am,

I have been more than happy to you can stay at my house because well thank you.

Thank you. Yeah,

we've missed traveling around the world as we did. Pre covid.

So thank you for joining us and for the kind offer we do hope to make our

way to India and elsewhere in the world in the coming years as things get healthier.

Maybe time for two more questions if we could john

Yes. Um

as far as Reggie expression um

The to limit the maximum and the minimum amount of characters.

What if you could have only two characters to

16 characters or two characters to eight characters.

Yes.

Have I got the syntax for you this one here.

So we didn't use it in any demos. It was just listed here.

If you use curly braces, you can specify a specific number

or a range of values for repetitions, so you pretty much have everything

available to you

and I hope folks won't mind that will squeeze in one

more question before we have to power down here others.

Let's see over to.

How about Ivan over to you.

Yeah, so um, my question is about sets. So we have a nested set of sets,

so basically how it affects the order of groups.

It's like the whole one group counting from the ultra most set

or it just increments going to the innermost set. You know, it's a good question.

So for clarity,

if you're using parentheses recall that are capturing information.

Uh

you can nest those two for whatever reason, if you want.

Honestly, I mean I always forget,

I think it's just like grade school math

where I think they get numbered from outer most

two innermost

from left to right.

Um I would google that if you don't mind. Like I would google nested

capturing parentheses order and see what pops up.

That's the kind of thing to where I try to avoid it just because it makes you think.

But I think that's the answer, but I would double check myself too.

Well if you don't mind.

Um we will post on the course's website as before today's souvenir photo.

Thank you so much for joining us for staying up so late.

Thank you for humoring me as I start to go off the

rails at the end and get confused by my own examples.

It was a long day here too,

but we'll clean all of that up when the final version goes online.

You get the uh live uncensored version here. But thank you all so much.

We were are off next week, but we'll see you again for the final weeks.

In two weeks time to have a wonderful morning, afternoon or evening. This was CS 50.

Mhm.

